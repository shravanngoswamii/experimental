Directory structure:
└── src/
    ├── App.vue
    ├── main.ts
    ├── assets/
    │   └── styles/
    │       └── global.css
    ├── components/
    │   ├── canvas/
    │   │   ├── CanvasToolbar.vue
    │   │   ├── GraphCanvas.vue
    │   │   └── GraphEditor.vue
    │   ├── layouts/
    │   │   ├── MainLayout.vue
    │   │   └── Navbar.vue
    │   ├── left-sidebar/
    │   │   ├── NodePalette.vue
    │   │   └── ProjectManager.vue
    │   ├── panels/
    │   │   ├── CodePreviewPanel.vue
    │   │   └── DataInputPanel.vue
    │   ├── right-sidebar/
    │   │   └── NodePropertiesPanel.vue
    │   ├── shared/
    │   │   └── Modal.vue
    │   └── ui/
    │       ├── BaseButton.vue
    │       ├── BaseInput.vue
    │       └── BaseSelect.vue
    ├── composables/
    │   ├── useGraphElements.ts
    │   ├── useGraphInstance.ts
    │   ├── useGraphSync.ts
    │   └── useGridSnapping.ts
    ├── stores/
    │   ├── graphStore.ts
    │   └── projectStore.ts
    └── types/
        ├── cytoscape-snap-to-grid.d.ts
        └── index.ts

================================================
File: App.vue
================================================
<script setup lang="ts">
import MainLayout from './components/layouts/MainLayout.vue'; // Import the main layout component
</script>

<template>
  <!--
    The App.vue component now primarily serves as the entry point for the Vue application.
    It imports and renders the MainLayout component, which defines the overall
    structure of the DoodleBUGS editor (sidebars, canvas).
    All global styling has been moved to src/assets/styles/global.css.
  -->
  <MainLayout />
</template>

<!--
  No <style> block here. All global styles are now in src/assets/styles/global.css.
  Component-specific styles will be defined within their respective .vue files
  using <style scoped>.
-->



================================================
File: main.ts
================================================
import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';
import './assets/styles/global.css'; // Import the consolidated global CSS file

const app = createApp(App);

app.use(createPinia()); // Use Pinia for state management

app.mount('#app'); // Mount the Vue application to the #app element



================================================
File: assets/styles/global.css
================================================
@import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css');


/* Basic CSS Reset & Variables */
:root {
  /* VS Code-inspired colors */
  --color-background: #f8f9fa; /* Lighter background for main content */
  --color-background-soft: #ffffff; /* White for panels/cards */
  --color-background-mute: #f1f3f5; /* Light grey for subtle backgrounds */
  --color-background-dark: #222222; /* Dark for code viewers and VS Code sidebar */

  --color-border: #dee2e6; /* Light border */
  --color-border-hover: #adb5bd; /* Border on hover */
  --color-border-light: #e9ecef; /* Even lighter border */
  --color-border-dark: #ced4da; /* Slightly darker border for contrast */

  --color-heading: #212529; /* Dark text for headings */
  --color-text: #343a40; /* Dark text for general content */
  --color-text-light: #f0f0f0; /* Light text for dark backgrounds */

  --color-primary: #007acc; /* VS Code blue for primary actions/accents */
  --color-primary-hover: #0060a0; /* Darker blue on hover */
  --color-secondary: #6c757d; /* Grey for secondary actions */
  --color-secondary-hover: #5a6268; /* Darker grey on hover */
  --color-success: #28a745; /* Green for success */
  --color-info: #17a2b8; /* Cyan for info */
  --color-warning: #ffc107; /* Yellow for warning */
  --color-danger: #dc3545; /* Red for danger */

  /* Layout dimensions */
  --navbar-height: 50px; /* New: Height of the top navigation bar */
  --vertical-tab-width: 50px; /* Width of the vertical tab strip (icons only) */
  --sidebar-content-width-left: 280px; /* Width of the left sidebar's content area when open */
  --sidebar-width-right: 320px; /* Width of the right sidebar */
  --menubar-height: 40px; /* Placeholder for a potential top menubar */

  /* Grid size for Cytoscape (default) */
  --grid-size: 20px;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
    Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  color: var(--color-text);
  background-color: var(--color-background);
  overflow: hidden; /* Prevent global scroll */
}

#app {
  display: flex;
  flex-direction: column;
  height: 100vh; /* Full viewport height */
  width: 100vw; /* Full viewport width */
  overflow: hidden; /* Prevent #app from scrolling */
}

/* Basic styling for common elements */
button, select, input[type="text"], input[type="number"], textarea {
  font-family: inherit;
  font-size: inherit;
  padding: 8px 12px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background-color: var(--color-background-soft);
  color: var(--color-text);
  box-sizing: border-box;
  cursor: pointer;
  transition: all 0.2s ease;
}

button {
  background-color: var(--color-background-mute);
}

button:hover {
  background-color: var(--color-border-light);
}

button.primary {
  background-color: var(--color-primary);
  color: white;
  border-color: var(--color-primary);
}

button.primary:hover {
  background-color: var(--color-primary-hover);
  border-color: var(--color-primary-hover);
}

button.secondary {
  background-color: var(--color-secondary);
  color: white;
  border-color: var(--color-secondary);
}

button.secondary:hover {
  background-color: var(--color-secondary-hover);
  border-color: var(--color-secondary-hover);
}

input[type="text"]:focus,
input[type="number"]:focus,
select:focus,
textarea:focus {
  border-color: var(--color-primary);
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

/* Basic utility classes */
.w-full { width: 100%; }
.h-full { height: 100%; }
.flex { display: flex; }
.flex-col { flex-direction: column; }
.flex-grow { flex-grow: 1; }
.justify-center { justify-content: center; }
.items-center { align-items: center; }
.text-center { text-align: center; }
.p-4 { padding: 1rem; }
.m-4 { margin: 1rem; }
.border { border: 1px solid var(--color-border); }
.rounded { border-radius: 0.25rem; }
.shadow-md { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }

/* Cytoscape specific styles for grid background */
.cytoscape-container.grid-background {
  background-image:
    linear-gradient(to right, var(--color-border-dark) 1px, transparent 1px),
    linear-gradient(to bottom, var(--color-border-dark) 1px, transparent 1px);
  background-size: var(--grid-size) var(--grid-size);
}

/* Base styles for modals (from Modal.vue, but globalized for consistency) */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  animation: fadeIn 0.2s ease-out;
}

.modal-content {
  background-color: white;
  padding: 25px;
  border-radius: 8px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  min-width: 350px;
  max-width: 90%;
  max-height: 90%;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 15px;
  position: relative;
  animation: slideIn 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--color-border-light);
  padding-bottom: 10px;
  margin-bottom: 15px;
}

.modal-header h3 {
  margin: 0;
  font-size: 1.2em;
  color: var(--color-heading);
}

.modal-close-button {
  background: none;
  border: none;
  font-size: 1.8em;
  cursor: pointer;
  color: var(--color-secondary);
  line-height: 1;
  padding: 0;
  transition: color 0.2s ease;
}

.modal-close-button:hover {
  color: var(--color-text);
}

.modal-body {
  flex-grow: 1; /* Allows body to take available space */
}

.modal-footer {
  border-top: 1px solid var(--color-border-light);
  padding-top: 15px;
  margin-top: 15px;
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  flex-shrink: 0; /* Prevent shrinking when content is tall */
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateY(-30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}



================================================
File: components/canvas/CanvasToolbar.vue
================================================
<script setup lang="ts">
import BaseButton from '../ui/BaseButton.vue';
import type { NodeType } from '../../types';

const props = defineProps<{
  currentMode: string; // 'select', 'add-node', 'add-edge'
  currentNodeType: NodeType; // The currently selected node type for adding
  isConnecting: boolean; // Whether an edge connection is in progress
  sourceNodeName: string | undefined; // Name of the source node if connecting
}>();

const emit = defineEmits<{
  (e: 'update:currentMode', mode: string): void;
  (e: 'update:currentNodeType', type: NodeType): void;
}>();

// Available node types for BUGS models
const availableNodeTypes: { label: string; value: NodeType }[] = [
  { label: 'Stochastic Node', value: 'stochastic' },
  { label: 'Deterministic Node', value: 'deterministic' },
  { label: 'Constant Node', value: 'constant' },
  { label: 'Observed Node', value: 'observed' },
  { label: 'Plate (Loop)', value: 'plate' },
];

/**
 * Sets the current mode of the graph editor.
 * @param mode The mode to set ('select', 'add-node', 'add-edge').
 */
const setMode = (mode: string) => {
  emit('update:currentMode', mode);
};

/**
 * Updates the currently selected node type for adding new nodes.
 * @param event The change event from the select element.
 */
const updateNodeType = (event: Event) => {
  const target = event.target as HTMLSelectElement;
  emit('update:currentNodeType', target.value as NodeType);
};
</script>

<template>
  <div class="canvas-toolbar">
    <BaseButton
      :class="{ active: currentMode === 'select' }"
      @click="setMode('select')"
    >
      Select
    </BaseButton>
    <BaseButton
      :class="{ active: currentMode === 'add-node' }"
      @click="setMode('add-node')"
    >
      Add Node
    </BaseButton>
    <BaseButton
      :class="{ active: currentMode === 'add-edge' }"
      @click="setMode('add-edge')"
    >
      Add Edge
    </BaseButton>

    <div v-if="currentMode === 'add-node'" class="node-type-selector">
      <label for="node-type">Node Type:</label>
      <select id="node-type" :value="currentNodeType" @change="updateNodeType">
        <option v-for="type in availableNodeTypes" :key="type.value" :value="type.value">
          {{ type.label }}
        </option>
      </select>
    </div>

    <span v-if="isConnecting" class="connecting-message">
      Connecting from: <strong>{{ sourceNodeName }}</strong> (Click target node)
    </span>
  </div>
</template>

<style scoped>
.canvas-toolbar {
  display: flex;
  gap: 10px;
  padding: 10px;
  background-color: var(--color-background-soft);
  border-bottom: 1px solid var(--color-border-light);
  align-items: center;
  flex-wrap: wrap; /* Allow items to wrap on smaller screens */
  flex-shrink: 0; /* Prevent toolbar from shrinking */
}

.canvas-toolbar .base-button {
  /* Override base button styles for toolbar specific look if needed */
  padding: 8px 15px;
  border: 1px solid var(--color-border-dark);
  background-color: #fff;
  cursor: pointer;
  border-radius: 4px;
  transition: background-color 0.2s ease, border-color 0.2s ease;
}

.canvas-toolbar .base-button.active {
  background-color: var(--color-primary);
  color: white;
  border-color: var(--color-primary);
}

.canvas-toolbar .base-button:hover:not(.active) {
  background-color: var(--color-border-light);
}

.node-type-selector {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-left: 10px; /* Spacing from buttons */
}

.node-type-selector label {
  font-size: 0.9em;
  color: #555;
}

.node-type-selector select {
  padding: 6px 8px;
  border: 1px solid var(--color-border-dark);
  border-radius: 4px;
  background-color: white;
  font-size: 0.9em;
  cursor: pointer;
}

.connecting-message {
  margin-left: auto; /* Push to the right */
  font-style: italic;
  color: #666;
  font-size: 0.9em;
  white-space: nowrap; /* Prevent message from wrapping */
}
</style>



================================================
File: components/canvas/GraphCanvas.vue
================================================
<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch } from 'vue';
import type { Core, EventObject, NodeSingular, EdgeSingular } from 'cytoscape';
import { useGraphInstance } from '../../composables/useGraphInstance';
import { useGridSnapping } from '../../composables/useGridSnapping';
import type { GraphElement, GraphNode, GraphEdge, NodeType, PaletteItemType } from '../../types';

const props = defineProps<{
  elements: GraphElement[]; // Graph elements from the store
  isGridEnabled: boolean;
  gridSize: number;
  currentMode: string; // To apply mode-specific cursors
}>();

const emit = defineEmits<{
  (e: 'canvas-tap', event: EventObject): void; // Emit the full Cytoscape EventObject
  (e: 'node-dragged', nodeData: GraphNode): void;
  (e: 'node-dropped', payload: { nodeType: NodeType; position: { x: number; y: number } }): void; // Event for node drop
}>();

const cyContainer = ref<HTMLElement | null>(null);
let cy: Core | null = null; // Local Cytoscape instance reference

// Composables
const { initCytoscape, destroyCytoscape, getCyInstance } = useGraphInstance();
const { enableGridSnapping, disableGridSnapping, setGridSize } = useGridSnapping(getCyInstance);

// Define valid node types that can be dragged and dropped from the palette
const validNodeTypes: NodeType[] = ['stochastic', 'deterministic', 'constant', 'observed', 'plate'];

onMounted(() => {
  if (cyContainer.value) {
    // Initialize Cytoscape instance
    cy = initCytoscape(cyContainer.value, props.elements);

    // Initial grid setup
    setGridSize(props.gridSize);
    if (props.isGridEnabled) {
      enableGridSnapping();
    } else {
      disableGridSnapping();
    }

    // --- Cytoscape Event Listeners ---
    // Tap event (for selection, adding nodes/edges)
    cy.on('tap', (evt: EventObject) => {
      emit('canvas-tap', evt); // Emit the raw Cytoscape EventObject
    });

    // Dragfree event (for snapping nodes after drag)
    cy.on('dragfree', 'node', (evt: EventObject) => {
      const node = evt.target as NodeSingular;
      // Snap node position to grid after drag, if grid is enabled
      const snappedPos = {
        x: Math.round(node.position('x') / props.gridSize) * props.gridSize,
        y: Math.round(node.position('y') / props.gridSize) * props.gridSize,
      };
      node.position(snappedPos); // Apply snapped position
      const nodeData = node.data() as GraphNode;
      emit('node-dragged', { ...nodeData, position: snappedPos }); // Emit updated position
    });

    // Handle selection styling directly here for Cytoscape elements
    cy.on('tap', 'node, edge', (evt: EventObject) => {
        cy?.elements().removeClass('cy-selected'); // Deselect all others
        evt.target.addClass('cy-selected'); // Add class to tapped element
    });
    cy.on('tap', (evt: EventObject) => {
        if (evt.target === cy) { // If background is tapped
            cy?.elements().removeClass('cy-selected'); // Deselect all
        }
    });

    // --- Drag and Drop for Node Palette ---
    // Allow dropping on the Cytoscape container
    cyContainer.value.addEventListener('dragover', (event) => {
      event.preventDefault(); // Necessary to allow a drop
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = 'copy'; // Show a copy cursor
      }
    });

    // Handle the drop event from the palette
    cyContainer.value.addEventListener('drop', (event) => {
      event.preventDefault(); // Prevent default browser drop behavior (e.g., opening file)

      if (event.dataTransfer) {
        const droppedItemType = event.dataTransfer.getData('text/plain') as PaletteItemType;
        console.log('Dropped item type:', droppedItemType); // Debugging: Check what type is being dropped

        // Check if the dropped item is a valid node type
        if (validNodeTypes.includes(droppedItemType as NodeType)) {
          // Get the position relative to the Cytoscape canvas
          const bbox = cyContainer.value?.getBoundingClientRect();
          if (bbox && cy) {
            const clientX = event.clientX;
            const clientY = event.clientY;

            // Convert client coordinates to Cytoscape model coordinates
            const renderedPos = {
              x: clientX - bbox.left,
              y: clientY - bbox.top
            };
            const modelPos = cy.panzoom().reverse(renderedPos); // Convert to model coordinates
            console.log('Dropped at model position:', modelPos); // Debugging: Check calculated position

            // Emit the node-dropped event with the node type and position
            emit('node-dropped', { nodeType: droppedItemType as NodeType, position: modelPos });
            console.log(`Emitting node-dropped: type=${droppedItemType}, pos=${JSON.stringify(modelPos)}`); // Debugging: Confirm emit
          } else {
            console.error("Bounding box or Cytoscape instance not available for drop event.");
          }
        } else {
          // If it's not a valid node type (e.g., an edge type from the palette),
          // log a warning and do not process it as a node drop.
          console.warn(`Dropped item type "${droppedItemType}" is not a recognized node type for direct drag-drop creation on canvas.`);
        }
      }
    });
  }
});

onUnmounted(() => {
  if (cy) {
    destroyCytoscape(cy);
  }
});

// Watch for grid changes from parent (MainLayout)
watch(() => props.isGridEnabled, (newValue) => {
  if (newValue) {
    enableGridSnapping();
  } else {
    disableGridSnapping();
  }
});

watch(() => props.gridSize, (newValue) => {
  setGridSize(newValue);
  // Re-enable snapping if already enabled to apply new grid size
  if (props.isGridEnabled) {
    enableGridSnapping();
  }
});

// Watch for changes in the `elements` prop and update the Cytoscape instance
watch(() => props.elements, (newElements, oldElements) => {
  if (cy) {
    const newElementIds = new Set(newElements.map(el => el.id));
    // Use batch for performance when making multiple changes to Cytoscape
    cy.batch(() => {
      // Remove elements that are in oldElements but not in newElements
      cy.elements().forEach(cyEl => {
        if (!newElementIds.has(cyEl.id())) {
          cyEl.remove();
        }
      });

      // Add or update elements
      newElements.forEach(newEl => {
        const existingCyEl = cy.getElementById(newEl.id);
        if (existingCyEl.empty()) { // Check if element exists in Cytoscape
          // Add new element if it doesn't exist
          if (newEl.type === 'node') {
            const nodeData = newEl as GraphNode;
            cy.add({
              group: 'nodes',
              data: nodeData,
              position: nodeData.position
            });
          } else if (newEl.type === 'edge') {
            const edgeData = newEl as GraphEdge;
            // Ensure source and target nodes exist before adding edge to prevent errors
            if (cy.getElementById(edgeData.source).length && cy.getElementById(edgeData.target).length) {
              cy.add({
                group: 'edges',
                data: edgeData,
                source: edgeData.source,
                target: edgeData.target
              });
            } else {
              console.warn(`Attempted to add edge ${edgeData.id} with non-existent source or target node.`);
            }
          }
        } else {
          // Update existing element's data if it exists
          existingCyEl.data(newEl);
          if (newEl.type === 'node') {
            const newNodePos = (newEl as GraphNode).position;
            const currentCyPos = existingCyEl.position();
            // Only update position if it has actually changed to avoid unnecessary re-renders
            if (newNodePos.x !== currentCyPos.x || newNodePos.y !== currentCyPos.y) {
              existingCyEl.position(newNodePos);
            }
          }
        }
      });
    });
  }
}, { deep: true }); // Deep watch is necessary for nested changes within elements
</script>

<template>
  <div
    ref="cyContainer"
    class="cytoscape-container"
    :class="{
      'grid-background': isGridEnabled && gridSize > 0,
      'mode-add-node': currentMode === 'add-node',
      'mode-add-edge': currentMode === 'add-edge',
      'mode-select': currentMode === 'select'
    }"
    :style="{ '--grid-size': `${gridSize}px` }"
  ></div>
</template>

<style scoped>
.cytoscape-container {
  flex-grow: 1;
  background-color: var(--color-background-soft);
  position: relative; /* Important for Cytoscape */
  overflow: hidden;
  cursor: grab; /* Default cursor */
}

/* Cursor styles based on mode */
.cytoscape-container.mode-add-node {
  cursor: crosshair;
}

.cytoscape-container.mode-add-edge {
  /* Custom arrow cursor for connecting mode */
  cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>') 12 12, crosshair;
}

/* Cytoscape selected class (applied internally by Cytoscape) */
/* These styles are now handled directly in useGraphInstance.ts stylesheet */
:deep(.cy-selected) {
  /* Keeping this empty to avoid conflicts if Cytoscape applies its own styles */
}

/* Style for connecting node (applied by GraphEditor) */
/* These styles are now handled directly in useGraphInstance.ts stylesheet */
:deep(.cy-connecting) {
  /* Keeping this empty to avoid conflicts if Cytoscape applies its own styles */
}
</style>



================================================
File: components/canvas/GraphEditor.vue
================================================
<script setup lang="ts">
import { ref, watch } from 'vue';
import type { NodeSingular, EventObject, Core } from 'cytoscape';
import GraphCanvas from './GraphCanvas.vue';
import CanvasToolbar from './CanvasToolbar.vue';
import { useGraphElements } from '../../composables/useGraphElements';
import { useGraphInstance } from '../../composables/useGraphInstance';
import type { GraphElement, GraphNode, GraphEdge, NodeType } from '../../types';

const props = defineProps<{
  isGridEnabled: boolean;
  gridSize: number;
  currentMode: string;
  currentNodeType: NodeType;
}>();

const emit = defineEmits<{
  (e: 'element-selected', element: GraphElement | null): void;
  (e: 'update:currentMode', mode: string): void;
  (e: 'update:currentNodeType', type: NodeType): void;
}>();

const { elements, addElement, updateElement, deleteElement } = useGraphElements();
const { getCyInstance } = useGraphInstance();

const sourceNode = ref<NodeSingular | null>(null);
const isConnecting = ref(false);

/**
 * Handles a tap event from the GraphCanvas to create nodes/edges.
 * @param event The Cytoscape EventObject.
 */
const handleCanvasTap = (event: EventObject) => {
  const { position, target } = event;
  const cy = getCyInstance() as Core;

  if (!cy) return;

  const isBackgroundClick = target === cy;
  const isPlateClick = !isBackgroundClick && target.isNode() && target.data('nodeType') === 'plate';
  const isNodeClick = !isBackgroundClick && target.isNode();
  const isEdgeClick = !isBackgroundClick && target.isEdge();

  switch (props.currentMode) {
    case 'add-node':
      // Allow adding a node on the background or directly inside a plate.
      if (isBackgroundClick || isPlateClick) {
        // Prevent adding a plate inside another plate.
        if (props.currentNodeType === 'plate' && isPlateClick) {
            alert("Nesting plates is not currently supported."); // Or use a custom modal
            return;
        }

        const newId = `node_${crypto.randomUUID().substring(0, 8)}`;
        const newNode: GraphNode = {
          id: newId,
          name: `${props.currentNodeType} ${elements.value.filter(e => e.type === 'node').length + 1}`,
          type: 'node',
          nodeType: props.currentNodeType,
          position: { x: position.x, y: position.y },
          parent: isPlateClick ? (target as NodeSingular).id() : undefined,
          distribution: props.currentNodeType === 'stochastic' ? 'dnorm' : undefined,
          equation: props.currentNodeType === 'deterministic' ? '' : undefined,
          observed: props.currentNodeType === 'observed' ? true : undefined,
          loopVariable: props.currentNodeType === 'plate' ? 'i' : undefined,
          loopRange: props.currentNodeType === 'plate' ? '1:N' : undefined,
        };
        addElement(newNode);
        emit('element-selected', newNode);
        emit('update:currentMode', 'select');
      }
      break;

    case 'add-edge':
      if (isNodeClick) {
        const tappedNode = target as NodeSingular;
        if (sourceNode.value && sourceNode.value.id() !== tappedNode.id()) {
          const newEdge: GraphEdge = {
            id: `edge_${crypto.randomUUID().substring(0, 8)}`,
            type: 'edge',
            source: sourceNode.value.id(),
            target: tappedNode.id(),
            name: `Edge ${sourceNode.value.data('name')} -> ${tappedNode.data('name')}`,
            relationshipType: 'deterministic'
          };
          addElement(newEdge);
          sourceNode.value?.removeClass('cy-connecting');
          sourceNode.value = null;
          isConnecting.value = false;
          emit('update:currentMode', 'select');
          emit('element-selected', newEdge);
        } else if (!sourceNode.value) {
          sourceNode.value = tappedNode;
          sourceNode.value.addClass('cy-connecting');
          isConnecting.value = true;
          emit('element-selected', sourceNode.value.data());
        }
      } else if (isBackgroundClick) {
        sourceNode.value?.removeClass('cy-connecting');
        sourceNode.value = null;
        isConnecting.value = false;
        emit('element-selected', null);
      }
      break;

    default: // 'select' mode
      if (isNodeClick || isEdgeClick) {
        emit('element-selected', target.data());
      } else if (isBackgroundClick) {
        emit('element-selected', null);
      }
      break;
  }
};


/**
 * Handles a node being dragged and dropped.
 * @param nodeData The updated data of the dragged node.
 */
const handleNodeDragged = (nodeData: GraphNode) => {
  updateElement(nodeData);
};

/**
 * Handles a node being dropped onto the canvas from the palette.
 * @param payload Contains the nodeType and the position where it was dropped.
 */
const handleNodeDropped = (payload: { nodeType: NodeType; position: { x: number; y: number } }) => {
  const { nodeType, position } = payload;
  const cy = getCyInstance();
  let parentPlateId: string | undefined = undefined;

  // Find if the drop position is inside any plate
  if (cy) {
    const plates = cy.nodes('[nodeType="plate"]');
    for (const plate of plates) {
      const bb = plate.boundingBox();
      if (position.x > bb.x1 && position.x < bb.x2 && position.y > bb.y1 && position.y < bb.y2) {
        // Prevent dropping a plate into a plate
        if (nodeType === 'plate') {
          alert("Nesting plates is not currently supported.");
          return;
        }
        parentPlateId = plate.id();
        break;
      }
    }
  }

  const newId = `node_${crypto.randomUUID().substring(0, 8)}`;
  const newNode: GraphNode = {
    id: newId,
    name: `${nodeType} ${elements.value.filter(e => e.type === 'node').length + 1}`,
    type: 'node',
    nodeType: nodeType,
    position: position,
    parent: parentPlateId,
    distribution: nodeType === 'stochastic' ? 'dnorm' : undefined,
    equation: nodeType === 'deterministic' ? '' : undefined,
    observed: nodeType === 'observed' ? true : undefined,
    loopVariable: nodeType === 'plate' ? 'i' : undefined,
    loopRange: nodeType === 'plate' ? '1:N' : undefined,
  };
  addElement(newNode);
  emit('element-selected', newNode);
  emit('update:currentMode', 'select');
};

// Watch for mode changes to reset connecting state
watch(() => props.currentMode, (newMode) => {
  if (newMode !== 'add-edge') {
    sourceNode.value?.removeClass('cy-connecting');
    sourceNode.value = null;
    isConnecting.value = false;
  }
});
</script>

<template>
  <div class="graph-editor-container">
    <CanvasToolbar
      :current-mode="props.currentMode"
      :current-node-type="props.currentNodeType"
      @update:current-mode="(mode) => emit('update:currentMode', mode)"
      @update:current-node-type="(type) => emit('update:currentNodeType', type)"
      :is-connecting="isConnecting"
      :source-node-name="sourceNode?.data('name')"
    />

    <GraphCanvas
      :elements="elements"
      :is-grid-enabled="isGridEnabled"
      :grid-size="gridSize"
      :current-mode="props.currentMode"
      @canvas-tap="handleCanvasTap"
      @node-dragged="handleNodeDragged"
      @node-dropped="handleNodeDropped" />
  </div>
</template>

<style scoped>
.graph-editor-container {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  position: relative;
  overflow: hidden;
}
</style>



================================================
File: components/layouts/MainLayout.vue
================================================
<script setup lang="ts">
import { ref, watch, computed } from 'vue';
import GraphEditor from '../canvas/GraphEditor.vue';
import ProjectManager from '../left-sidebar/ProjectManager.vue';
import NodePalette from '../left-sidebar/NodePalette.vue';
import DataInputPanel from '../panels/DataInputPanel.vue';
import NodePropertiesPanel from '../right-sidebar/NodePropertiesPanel.vue';
import CodePreviewPanel from '../panels/CodePreviewPanel.vue';
import Navbar from './Navbar.vue';
import Modal from '../shared/Modal.vue';
import BaseInput from '../ui/BaseInput.vue';
import BaseButton from '../ui/BaseButton.vue';

import { useGraphElements } from '../../composables/useGraphElements';
import { useProjectStore } from '../../stores/projectStore';
import { useGraphStore } from '../../stores/graphStore';
import type { GraphElement, NodeType, PaletteItemType } from '../../types';

// Pinia Stores
const projectStore = useProjectStore();
const graphStore = useGraphStore();
const { selectedElement, updateElement, deleteElement } = useGraphElements();

// UI State
const activeLeftTab = ref<'project' | 'palette' | 'data' | null>('project');
const activeRightTab = ref<'properties' | 'code'>('properties');
const isLeftSidebarOpen = ref(true);
const isRightSidebarOpen = ref(true);
const currentMode = ref<string>('select');
const currentNodeType = ref<NodeType>('stochastic');
const isGridEnabled = ref(true);
const gridSize = ref(20);

// Modal State
const showNewProjectModal = ref(false);
const newProjectName = ref('');
const showNewGraphModal = ref(false);
const newGraphName = ref('');

// --- FIX: Add computed properties for navbar ---
const currentProjectName = computed(() => projectStore.currentProject?.name || null);
const activeGraphName = computed(() => {
  if (projectStore.currentProject && graphStore.currentGraphId) {
    const graphMeta = projectStore.currentProject.graphs.find(g => g.id === graphStore.currentGraphId);
    return graphMeta?.name || null;
  }
  return null;
});

const handleLeftTabClick = (tabName: 'project' | 'palette' | 'data') => {
  if (activeLeftTab.value === tabName && isLeftSidebarOpen.value) {
    isLeftSidebarOpen.value = false;
  } else {
    isLeftSidebarOpen.value = true;
    activeLeftTab.value = tabName;
  }
};

// --- FIX: Update toggle functions to simply invert the state ---
const toggleLeftSidebar = () => {
  isLeftSidebarOpen.value = !isLeftSidebarOpen.value;
};

const toggleRightSidebar = () => {
  isRightSidebarOpen.value = !isRightSidebarOpen.value;
};

// Computed styles for sidebars
const leftSidebarContentStyle = computed(() => ({
  width: isLeftSidebarOpen.value ? 'var(--sidebar-content-width-left)' : '0',
  opacity: isLeftSidebarOpen.value ? '1' : '0',
  pointerEvents: isLeftSidebarOpen.value ? 'auto' : 'none',
}));
const leftSidebarClass = computed(() => ({
  'left-sidebar': true,
  'sidebar-collapsed-content': !isLeftSidebarOpen.value,
}));
const rightSidebarStyle = computed(() => ({
  width: isRightSidebarOpen.value ? 'var(--sidebar-width-right)' : '0',
  opacity: isRightSidebarOpen.value ? '1' : '0',
  pointerEvents: isRightSidebarOpen.value ? 'auto' : 'none',
  borderLeft: isRightSidebarOpen.value ? '1px solid var(--color-border)' : 'none',
}));


const handleElementSelected = (element: GraphElement | null) => {
  selectedElement.value = element;
};

const handleUpdateElement = (updatedEl: GraphElement) => {
  updateElement(updatedEl);
};

const handleDeleteElement = (elementId: string) => {
  deleteElement(elementId);
};

const handlePaletteSelection = (itemType: PaletteItemType) => {
  if (itemType === 'add-stochastic-edge' || itemType === 'add-deterministic-edge') {
    currentMode.value = 'add-edge';
  } else {
    currentMode.value = 'add-node';
    currentNodeType.value = itemType as NodeType;
  }
  isLeftSidebarOpen.value = false;
};

// Project and Graph Creation Logic
const createNewProject = () => {
  if (newProjectName.value.trim()) {
    projectStore.createProject(newProjectName.value.trim());
    showNewProjectModal.value = false;
    newProjectName.value = '';
    activeLeftTab.value = 'project';
    isLeftSidebarOpen.value = true;
  }
};

const createNewGraph = () => {
  if (projectStore.currentProject && newGraphName.value.trim()) {
    projectStore.addGraphToProject(projectStore.currentProject.id, newGraphName.value.trim());
    showNewGraphModal.value = false;
    newGraphName.value = '';
    activeLeftTab.value = 'project';
    isLeftSidebarOpen.value = true;
  }
};

const saveCurrentGraph = () => {
  if (graphStore.currentGraphId) {
    graphStore.saveGraph(graphStore.currentGraphId, graphStore.graphContents.get(graphStore.currentGraphId)!);
    console.log(`Graph "${graphStore.currentGraphId}" saved.`);
  } else {
    console.warn("No graph currently selected to save.");
  }
};

watch(selectedElement, (newVal) => {
  console.log('Selected element changed in MainLayout:', newVal);
}, { deep: true });
</script>

<template>
  <div class="main-layout">
    <Navbar
      :project-name="currentProjectName"
      :active-graph-name="activeGraphName"
      :is-grid-enabled="isGridEnabled"
      @update:is-grid-enabled="isGridEnabled = $event"
      :grid-size="gridSize"
      @update:grid-size="gridSize = $event"
      :current-mode="currentMode"
      @update:current-mode="currentMode = $event"
      :current-node-type="currentNodeType"
      @update:current-node-type="currentNodeType = $event"
      :is-left-sidebar-open="isLeftSidebarOpen"
      :is-right-sidebar-open="isRightSidebarOpen"
      @toggle-left-sidebar="toggleLeftSidebar"
      @toggle-right-sidebar="toggleRightSidebar"
      @new-project="showNewProjectModal = true"
      @new-graph="showNewGraphModal = true"
      @save-current-graph="saveCurrentGraph"
    />

    <div class="content-area">
      <aside :class="leftSidebarClass">
        <div class="vertical-tabs-container">
          <button :class="{ active: activeLeftTab === 'project' }" @click="handleLeftTabClick('project')" title="Project Manager">
            <i class="fas fa-folder"></i> <span v-show="isLeftSidebarOpen">Project</span>
          </button>
          <button :class="{ active: activeLeftTab === 'palette' }" @click="handleLeftTabClick('palette')" title="Node Palette">
            <i class="fas fa-shapes"></i> <span v-show="isLeftSidebarOpen">Palette</span>
          </button>
          <button :class="{ active: activeLeftTab === 'data' }" @click="handleLeftTabClick('data')" title="Data Input">
            <i class="fas fa-database"></i> <span v-show="isLeftSidebarOpen">Data</span>
          </button>
        </div>
        <div class="left-sidebar-content" :style="leftSidebarContentStyle">
          <div v-show="activeLeftTab === 'project'"><ProjectManager /></div>
          <div v-show="activeLeftTab === 'palette'"><NodePalette @select-palette-item="handlePaletteSelection" /></div>
          <div v-show="activeLeftTab === 'data'"><DataInputPanel /></div>
        </div>
      </aside>

      <main class="graph-editor-wrapper">
        <GraphEditor
          :is-grid-enabled="isGridEnabled"
          :grid-size="gridSize"
          :current-mode="currentMode"
          :current-node-type="currentNodeType"
          @update:current-mode="currentMode = $event"
          @update:current-node-type="currentNodeType = $event"
          @element-selected="handleElementSelected"
        />
      </main>

      <aside class="right-sidebar" :style="rightSidebarStyle">
        <div class="tabs-header">
          <button :class="{ active: activeRightTab === 'properties' }" @click="activeRightTab = 'properties'">Properties</button>
          <button :class="{ active: activeRightTab === 'code' }" @click="activeRightTab = 'code'">Code</button>
        </div>
        <div class="tabs-content">
          <div v-show="activeRightTab === 'properties'">
            <NodePropertiesPanel :selected-element="selectedElement" @update-element="handleUpdateElement" @delete-element="handleDeleteElement"/>
          </div>
          <div v-show="activeRightTab === 'code'"><CodePreviewPanel /></div>
        </div>
      </aside>
    </div>

    <!-- Modals for new project and new graph -->
    <Modal :is-open="showNewProjectModal" @close="showNewProjectModal = false">
      <template #header><h3>Create New Project</h3></template>
      <template #body>
          <label for="new-project-name" style="display: block; margin-bottom: 8px; font-weight: 500;">Project Name:</label>
          <BaseInput id="new-project-name" v-model="newProjectName" placeholder="Enter project name" @keyup.enter="createNewProject" />
      </template>
      <template #footer>
        <BaseButton @click="showNewProjectModal = false" type="secondary">Cancel</BaseButton>
        <BaseButton @click="createNewProject" type="primary">Create</BaseButton>
      </template>
    </Modal>

    <Modal :is-open="showNewGraphModal" @close="showNewGraphModal = false">
      <template #header><h3>Create New Graph</h3></template>
      <template #body>
          <label for="new-graph-name" style="display: block; margin-bottom: 8px; font-weight: 500;">Graph Name:</label>
          <BaseInput id="new-graph-name" v-model="newGraphName" placeholder="Enter graph name" @keyup.enter="createNewGraph" />
      </template>
      <template #footer>
        <BaseButton @click="showNewGraphModal = false" type="secondary">Cancel</BaseButton>
        <BaseButton @click="createNewGraph" type="primary">Create</BaseButton>
      </template>
    </Modal>
  </div>
</template>

<style scoped>
.main-layout {
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.content-area {
  display: flex;
  flex-grow: 1;
  overflow: hidden;
}

/* Left Sidebar Styling */
.left-sidebar {
  display: flex;
  background-color: var(--color-background-soft);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  z-index: 10;
  flex-shrink: 0;
  border-right: 1px solid var(--color-border);
  transition: width 0.3s ease-in-out;
}
.left-sidebar:not(.sidebar-collapsed-content) {
  width: calc(var(--vertical-tab-width) + var(--sidebar-content-width-left));
}
.left-sidebar.sidebar-collapsed-content {
  width: var(--vertical-tab-width);
}
.vertical-tabs-container {
  display: flex;
  flex-direction: column;
  width: var(--vertical-tab-width);
  border-right: 1px solid var(--color-border-light);
  background-color: var(--color-background-dark);
  padding-top: 10px;
  flex-shrink: 0;
}
.vertical-tabs-container button {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  padding: 10px 0;
  border: none;
  background-color: transparent;
  color: var(--color-text-light);
  font-size: 0.75em;
  font-weight: 500;
  transition: all 0.2s ease;
  gap: 5px;
  cursor: pointer;
  white-space: nowrap;
}
.vertical-tabs-container button i {
  font-size: 1.3em;
  color: var(--color-secondary);
  transition: color 0.2s ease;
}
.vertical-tabs-container button:hover {
  background-color: var(--color-primary-hover);
  color: white;
}
.vertical-tabs-container button:hover i {
  color: white;
}
.vertical-tabs-container button.active {
  background-color: var(--color-primary);
  color: white;
  border-left: 2px solid white;
}
.vertical-tabs-container button.active i {
  color: white;
}
.left-sidebar-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 15px;
  -webkit-overflow-scrolling: touch;
  transition: width 0.3s ease-in-out, opacity 0.3s ease-in-out;
  box-sizing: border-box;
}

/* Right Sidebar Styling */
.right-sidebar {
  display: flex;
  flex-direction: column;
  background-color: var(--color-background-soft);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  z-index: 10;
  flex-shrink: 0;
  transition: width 0.3s ease-in-out, opacity 0.3s ease-in-out;
}
.tabs-header {
  display: flex;
  border-bottom: 1px solid var(--color-border-light);
  flex-shrink: 0;
}
.tabs-header button {
  flex: 1;
  padding: 10px 15px;
  border: none;
  background-color: transparent;
  border-bottom: 2px solid transparent;
  font-weight: 500;
  color: var(--color-text);
  transition: all 0.2s ease;
  white-space: nowrap;
}
.tabs-header button:hover {
  background-color: var(--color-background-mute);
}
.tabs-header button.active {
  color: var(--color-primary);
  border-bottom-color: var(--color-primary);
  background-color: var(--color-background-soft);
}
.tabs-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 15px;
  -webkit-overflow-scrolling: touch;
}

/* Middle Graph Editor Area Styling */
.graph-editor-wrapper {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  position: relative;
  background-color: var(--color-background-mute);
  min-width: 0;
}
</style>



================================================
File: components/layouts/Navbar.vue
================================================
<script setup lang="ts">
import { reactive, onMounted, onUnmounted, computed } from 'vue';
import type { NodeType } from '../../types';
import BaseButton from '../ui/BaseButton.vue';
import BaseInput from '../ui/BaseInput.vue';

const props = defineProps<{
  projectName: string | null;
  activeGraphName: string | null; // Prop for the active graph's name
  isGridEnabled: boolean;
  gridSize: number;
  currentMode: string;
  currentNodeType: NodeType;
  isLeftSidebarOpen: boolean;
  isRightSidebarOpen: boolean;
}>();

const emit = defineEmits<{
  (e: 'update:isGridEnabled', value: boolean): void;
  (e: 'update:gridSize', value: number): void;
  (e: 'update:currentMode', mode: string): void;
  (e: 'update:currentNodeType', type: NodeType): void;
  (e: 'new-project'): void;
  (e: 'new-graph'): void;
  (e: 'save-current-graph'): void;
  (e: 'toggle-left-sidebar'): void;
  (e: 'toggle-right-sidebar'): void;
}>();

const menuState = reactive({
  project: false,
  add: false,
  view: false,
  help: false,
});

// Computed property to format the project and graph name display
const displayTitle = computed(() => {
  if (props.projectName && props.activeGraphName) {
    return `${props.projectName} — ${props.activeGraphName}`;
  }
  if (props.projectName) {
    return props.projectName;
  }
  return 'No Project Selected';
});

const basicNodeTypes: { label: string; value: NodeType }[] = [
  { label: 'Stochastic Node', value: 'stochastic' },
  { label: 'Deterministic Node', value: 'deterministic' },
  { label: 'Constant Node', value: 'constant' },
  { label: 'Observed Node', value: 'observed' },
  { label: 'Plate (Loop)', value: 'plate' },
];

const toggleMenu = (menuKey: keyof typeof menuState) => {
  const currentState = menuState[menuKey];
  Object.keys(menuState).forEach(k => {
    menuState[k as keyof typeof menuState] = false;
  });
  menuState[menuKey] = !currentState;
};

const setMode = (mode: string) => {
  emit('update:currentMode', mode);
  menuState.add = false;
};

const setAddNodeType = (type: NodeType) => {
  emit('update:currentNodeType', type);
  emit('update:currentMode', 'add-node');
  menuState.add = false;
};

const handleGridSizeInput = (event: Event) => {
  const target = event.target as HTMLInputElement;
  emit('update:gridSize', Number(target.value));
};

const handleClickOutside = (event: MouseEvent) => {
  const target = event.target as HTMLElement;
  if (!target.closest('.navbar-menu')) {
    Object.keys(menuState).forEach(k => {
      menuState[k as keyof typeof menuState] = false;
    });
  }
};

onMounted(() => {
  document.addEventListener('click', handleClickOutside);
});

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
});
</script>

<template>
  <nav class="navbar">
    <!-- Left Section: App Name and Main Menus -->
    <div class="navbar-left">
      <div class="navbar-brand">DoodleBUGS</div>
      <div class="navbar-menu">
        <div class="menu-item" @click.stop="toggleMenu('project')">
          <BaseButton type="secondary" size="small">Project</BaseButton>
          <div v-if="menuState.project" class="dropdown-content" @click.stop>
            <a href="#" @click.prevent="emit('new-project')">New Project...</a>
            <a href="#" @click.prevent="emit('new-graph')">New Graph...</a>
            <a href="#" @click.prevent="emit('save-current-graph')">Save Current Graph</a>
          </div>
        </div>
        <div class="menu-item" @click.stop="toggleMenu('add')">
          <BaseButton type="secondary" size="small">Add</BaseButton>
          <div v-if="menuState.add" class="dropdown-content" @click.stop>
            <div class="dropdown-section-title">Nodes</div>
            <a v-for="nodeType in basicNodeTypes" :key="nodeType.value" href="#" @click.prevent="setAddNodeType(nodeType.value)">
              {{ nodeType.label }}
            </a>
            <div class="dropdown-divider"></div>
            <a href="#" @click.prevent="setMode('add-edge')">Add Edge</a>
          </div>
        </div>
        <div class="menu-item" @click.stop="toggleMenu('view')">
          <BaseButton type="secondary" size="small">View</BaseButton>
          <div v-if="menuState.view" class="dropdown-content" @click.stop>
            <label class="dropdown-checkbox">
              <input type="checkbox" :checked="isGridEnabled" @change="emit('update:isGridEnabled', ($event.target as HTMLInputElement).checked)" />
              Show Grid
            </label>
            <div class="dropdown-input-group">
              <label for="grid-size-nav">Grid Size:</label>
              <BaseInput id="grid-size-nav" type="number" :model-value="gridSize" @input="handleGridSizeInput" min="10" max="100" step="5" class="w-20" />
              <span>px</span>
            </div>
          </div>
        </div>
        <div class="menu-item" @click.stop="toggleMenu('help')">
          <BaseButton type="secondary" size="small">Help</BaseButton>
          <div v-if="menuState.help" class="dropdown-content" @click.stop>
            <a href="#" @click.prevent="() => {}">About DoodleBUGS</a>
            <!-- FIX: Added missing menu items back -->
            <span class="dropdown-item-placeholder">Documentation (Coming Soon)</span>
            <a href="#" @click.prevent="() => {}">Report an Issue</a>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Section: Pane Toggles & Project Name -->
    <div class="navbar-right">
      <!-- FIX: Reordered pane toggles to be before the project name -->
      <div class="pane-toggles">
        <button @click="emit('toggle-left-sidebar')" :class="{ active: isLeftSidebarOpen }" title="Toggle Left Sidebar">
          <svg viewBox="0 0 64 64" fill="currentColor" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <path d="M49.984,56l-35.989,0c-3.309,0 -5.995,-2.686 -5.995,-5.995l0,-36.011c0,-3.308 2.686,-5.995 5.995,-5.995l35.989,0c3.309,0 5.995,2.687 5.995,5.995l0,36.011c0,3.309 -2.686,5.995 -5.995,5.995Zm-25.984,-4.001l0,-39.999l-9.012,0c-1.65,0 -2.989,1.339 -2.989,2.989l0,34.021c0,1.65 1.339,2.989 2.989,2.989l9.012,0Zm24.991,-39.999l-20.991,0l0,39.999l20.991,0c1.65,0 2.989,-1.339 2.989,-2.989l0,-34.021c0,-1.65 -1.339,-2.989 -2.989,-2.989Z"></path>
          </svg>
        </button>
        <button @click="emit('toggle-right-sidebar')" :class="{ active: isRightSidebarOpen }" title="Toggle Right Sidebar">
           <svg viewBox="0 0 64 64" fill="currentColor" version="1.1" xmlns="http://www.w3.org/2000/svg" transform="matrix(-1, 0, 0, 1, 0, 0)">
            <path d="M49.984,56l-35.989,0c-3.309,0 -5.995,-2.686 -5.995,-5.995l0,-36.011c0,-3.308 2.686,-5.995 5.995,-5.995l35.989,0c3.309,0 5.995,2.687 5.995,5.995l0,36.011c0,3.309 -2.686,5.995 -5.995,5.995Zm-25.984,-4.001l0,-39.999l-9.012,0c-1.65,0 -2.989,1.339 -2.989,2.989l0,34.021c0,1.65 1.339,2.989 2.989,2.989l9.012,0Zm24.991,-39.999l-20.991,0l0,39.999l20.991,0c1.65,0 2.989,-1.339 2.989,-2.989l0,-34.021c0,-1.65 -1.339,-2.989 -2.989,-2.989Z"></path>
          </svg>
        </button>
      </div>
      <span class="project-name">{{ displayTitle }}</span>
    </div>
  </nav>
</template>

<style scoped>
.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--color-background-dark);
  color: var(--color-text-light);
  padding: 0 20px;
  height: var(--navbar-height);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  z-index: 50;
  flex-shrink: 0;
}

.navbar-left,
.navbar-right {
  display: flex;
  align-items: center;
  gap: 20px;
}

.navbar-brand {
  font-size: 1.3em;
  font-weight: 600;
  color: white;
}

.project-name {
  font-size: 1em;
  color: var(--color-text-light);
  opacity: 0.8;
  white-space: nowrap;
}

.navbar-menu {
  display: flex;
  gap: 5px;
}

.menu-item {
  position: relative;
  display: flex;
  align-items: center;
}

.menu-item .base-button {
  background-color: transparent;
  border: none;
  color: var(--color-text-light);
  padding: 6px 10px;
  border-radius: 4px;
  font-weight: 500;
  transition: background-color 0.2s ease;
}

.menu-item .base-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.dropdown-content {
  position: absolute;
  top: calc(100% + 5px);
  left: 0;
  background-color: var(--color-background-soft);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border-radius: 6px;
  min-width: 220px;
  z-index: 60;
  display: flex;
  flex-direction: column;
  padding: 8px 0;
  border: 1px solid var(--color-border-light);
  animation: fadeInDown 0.2s ease-out;
}

.dropdown-content a {
  padding: 10px 15px;
  color: var(--color-text);
  text-decoration: none;
  display: block;
  font-size: 0.9em;
}

.dropdown-content a:hover {
  background-color: var(--color-primary);
  color: white;
}

.dropdown-divider {
  height: 1px;
  background-color: var(--color-border-light);
  margin: 8px 0;
}

.dropdown-section-title {
  padding: 5px 15px;
  font-size: 0.8em;
  color: var(--color-secondary);
  text-transform: uppercase;
  font-weight: 600;
}

.dropdown-checkbox, .dropdown-input-group {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 15px;
  font-size: 0.9em;
  color: var(--color-text);
  cursor: pointer;
}

.dropdown-checkbox input[type="checkbox"] {
  cursor: pointer;
}

.dropdown-checkbox:hover {
  background-color: var(--color-background-mute);
}

.dropdown-input-group .base-input {
  width: 50px;
}

.dropdown-item-placeholder {
  padding: 10px 15px;
  color: var(--color-secondary);
  font-size: 0.9em;
  cursor: default;
  opacity: 0.7;
}

.pane-toggles {
  display: flex;
  align-items: center;
  gap: 5px;
  border: 1px solid #555;
  border-radius: 5px;
  padding: 2px;
}

.pane-toggles button {
  background-color: transparent;
  border: 1px solid transparent;
  color: var(--color-text-light);
  opacity: 0.7;
  padding: 4px;
  border-radius: 3px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
}

.pane-toggles button:hover {
  opacity: 1;
  background-color: rgba(255, 255, 255, 0.1);
}

.pane-toggles button.active {
  opacity: 1;
  background-color: var(--color-primary);
  color: white;
}

.pane-toggles button svg {
  width: 18px;
  height: 18px;
}

@keyframes fadeInDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}
</style>



================================================
File: components/left-sidebar/NodePalette.vue
================================================
<script setup lang="ts">
import type { NodeType, PaletteItemType } from '../../types';

const emit = defineEmits<{
  (e: 'select-palette-item', itemType: PaletteItemType): void;
}>();

// Define the available node types for the palette
const nodeItems: { label: string; type: NodeType; icon: string; styleClass: string; description: string }[] = [
  { label: 'Stochastic', type: 'stochastic', icon: '~', styleClass: 'stochastic', description: 'Random variable with a distribution' },
  { label: 'Deterministic', type: 'deterministic', icon: '<-', styleClass: 'deterministic', description: 'Logical function of parents' },
  { label: 'Constant', type: 'constant', icon: 'C', styleClass: 'constant', description: 'A fixed value or parameter' },
  { label: 'Observed', type: 'observed', icon: 'O', styleClass: 'observed', description: 'A data node with a fixed value' },
  { label: 'Plate', type: 'plate', icon: '[]', styleClass: 'plate', description: 'Represents a loop structure' },
];

// Define connection types for the palette
const connectionItems: { label: string; type: 'add-stochastic-edge' | 'add-deterministic-edge'; styleClass: string; description: string }[] = [
  { label: 'Stochastic (~)', type: 'add-stochastic-edge', styleClass: 'stochastic', description: 'Stochastic dependency' },
  { label: 'Deterministic (<--)', type: 'add-deterministic-edge', styleClass: 'deterministic', description: 'Logical dependency' },
];

/**
 * Handles the drag start event for a palette item.
 * @param event The DragEvent object.
 * @param itemType The type of item being dragged.
 */
const onDragStart = (event: DragEvent, itemType: PaletteItemType) => {
  if (event.dataTransfer) {
    event.dataTransfer.setData('text/plain', itemType);
    event.dataTransfer.effectAllowed = 'copy';
  }
};

/**
 * Handles the click event on a palette item.
 * @param itemType The type of item that was clicked.
 */
const onClickPaletteItem = (itemType: PaletteItemType) => {
  emit('select-palette-item', itemType);
};
</script>

<template>
  <div class="node-palette">
    <div class="palette-section">
      <h5 class="section-title">Nodes</h5>
      <div class="palette-grid">
        <div
          v-for="node in nodeItems"
          :key="node.type"
          class="palette-card"
          :class="node.styleClass"
          draggable="true"
          @dragstart="onDragStart($event, node.type)"
          @click="onClickPaletteItem(node.type)"
          :title="node.description"
        >
          <div class="card-icon" :class="`icon-${node.type}`">{{ node.icon }}</div>
          <span class="card-label">{{ node.label }}</span>
        </div>
      </div>
    </div>

    <div class="palette-section">
      <h5 class="section-title">Connections</h5>
      <div class="palette-grid">
        <div
          v-for="connection in connectionItems"
          :key="connection.type"
          class="palette-card"
          :class="connection.styleClass"
          draggable="true"
          @dragstart="onDragStart($event, connection.type)"
          @click="onClickPaletteItem(connection.type)"
          :title="connection.description"
        >
          <div class="card-icon connection-icon" :class="`icon-${connection.type}`"></div>
          <span class="card-label">{{ connection.label }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.node-palette {
  padding: 12px;
  background-color: var(--color-background-soft);
  height: 100%;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.palette-section {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.section-title {
  font-size: 0.9em;
  font-weight: 600;
  color: var(--color-heading);
  padding-bottom: 8px;
  border-bottom: 1px solid var(--color-border-light);
  margin: 0;
}

.palette-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
}

.palette-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 15px 10px;
  border-radius: 8px;
  border: 1px solid var(--color-border);
  background-color: #fff;
  cursor: grab;
  text-align: center;
  transition: all 0.2s ease-in-out;
  user-select: none;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.palette-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  border-color: var(--color-primary);
}

.palette-card:active {
  cursor: grabbing;
  transform: translateY(-1px);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.card-label {
  font-size: 0.8em;
  font-weight: 500;
  color: var(--color-text);
  margin-top: 8px;
}

.card-icon {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
  font-weight: bold;
  border-radius: 50%;
  color: #fff;
}

/* Node Specific Styles */
.icon-stochastic { background-color: #dc3545; }
.icon-deterministic { background-color: #28a745; border-radius: 8px; font-size: 1.2em; }
.icon-constant { background-color: #6c757d; border-radius: 4px; }
.icon-observed {
  background-color: #fff;
  border: 2px dashed #007bff;
  color: #007bff;
}
.icon-plate {
  background-color: #fff;
  border: 2px dashed #495057;
  color: #495057;
  border-radius: 8px;
  font-size: 1.2em;
}

/* Connection Specific Styles */
.connection-icon {
  width: 100%;
  height: 20px;
  background-color: transparent !important;
  position: relative;
  border-radius: 0;
}

.connection-icon::before { /* The line */
  content: '';
  position: absolute;
  left: 10%;
  right: 10%;
  top: 50%;
  height: 2px;
  transform: translateY(-50%);
}

.connection-icon::after { /* The arrowhead */
  content: '';
  position: absolute;
  right: 10%;
  top: 50%;
  transform: translateY(-50%);
  width: 0;
  height: 0;
  border-style: solid;
}

.icon-add-stochastic-edge::before {
  border-top: 2px dashed #dc3545;
}
.icon-add-stochastic-edge::after {
  border-width: 6px 0 6px 10px;
  border-color: transparent transparent transparent #dc3545;
}

.icon-add-deterministic-edge::before {
  background-color: #28a745;
}
.icon-add-deterministic-edge::after {
  border-width: 6px 0 6px 10px;
  border-color: transparent transparent transparent #28a745;
}

</style>



================================================
File: components/left-sidebar/ProjectManager.vue
================================================
<script setup lang="ts">
import { ref, onMounted, computed } from 'vue';
import { useProjectStore } from '../../stores/projectStore';
import { useGraphStore } from '../../stores/graphStore';
import BaseButton from '../ui/BaseButton.vue';
import Modal from '../shared/Modal.vue'; // FIX: Added missing import for Modal

const projectStore = useProjectStore();
const graphStore = useGraphStore(); // To manage current graph

const showDeleteConfirmModal = ref(false);
const itemToDelete = ref<{ type: 'project' | 'graph', id: string, name: string, projectId?: string } | null>(null);

const currentProject = computed(() => projectStore.currentProject);
const currentProjectGraphs = computed(() => {
  if (currentProject.value) {
    return projectStore.getGraphsForProject(currentProject.value.id);
  }
  return [];
});

onMounted(() => {
  projectStore.loadProjects(); // Load projects on component mount
  // If no current project is selected, but projects exist, select the first one
  if (projectStore.projects.length > 0 && !projectStore.currentProjectId) {
    projectStore.selectProject(projectStore.projects[0].id);
  }
});

/**
 * Selects a graph to be displayed in the editor.
 * @param graphId The ID of the graph to select.
 */
const selectGraph = (graphId: string) => {
  graphStore.selectGraph(graphId); // Update the graph store with the selected graph
};

/**
 * Prepares the confirmation modal for deleting an item (project or graph).
 * @param type The type of item to delete ('project' or 'graph').
 * @param id The ID of the item.
 * @param name The name of the item.
 * @param projectId (Optional) The project ID if deleting a graph.
 */
const confirmDeletion = (type: 'project' | 'graph', id: string, name: string, projectId?: string) => {
  itemToDelete.value = { type, id, name, projectId };
  showDeleteConfirmModal.value = true;
};

/**
 * Executes the deletion after user confirmation.
 */
const executeDeletion = () => {
  if (itemToDelete.value) {
    if (itemToDelete.value.type === 'project') {
      projectStore.deleteProject(itemToDelete.value.id);
    } else if (itemToDelete.value.type === 'graph' && itemToDelete.value.projectId) {
      projectStore.deleteGraphFromProject(itemToDelete.value.projectId, itemToDelete.value.id);
      // If the deleted graph was the current one, deselect it
      if (graphStore.currentGraphId === itemToDelete.value.id) {
        graphStore.selectGraph(null);
      }
    }
    showDeleteConfirmModal.value = false;
    itemToDelete.value = null;
  }
};

/**
 * Cancels the deletion process.
 */
const cancelDeletion = () => {
  showDeleteConfirmModal.value = false;
  itemToDelete.value = null;
};
</script>

<template>
  <div class="project-manager">
    <div class="header">
      <h4>Projects</h4>
      <!-- New Project button removed, now in Navbar -->
    </div>

    <div v-if="projectStore.projects.length === 0" class="empty-state">
      No projects found. Create one using the "Project" menu in the navigation bar to get started!
    </div>

    <div v-else class="project-list">
      <div v-for="project in projectStore.projects" :key="project.id" class="project-item">
        <div class="project-header" @click="projectStore.selectProject(project.id)">
          <i class="icon-folder">📁</i>
          <span>{{ project.name }}</span>
          <BaseButton @click.stop="confirmDeletion('project', project.id, project.name)" type="danger" size="small" class="delete-btn">X</BaseButton>
        </div>
        <div v-if="projectStore.currentProject?.id === project.id" class="graph-list">
          <div class="graph-header">
            <h5>Graphs</h5>
            <!-- New Graph button removed, now in Navbar -->
          </div>
          <div v-if="currentProjectGraphs.length === 0" class="empty-state">
            No graphs in this project. Create one using the "Project" menu in the navigation bar.
          </div>
          <div v-else>
            <div
              v-for="graph in currentProjectGraphs"
              :key="graph.id"
              class="graph-item"
              :class="{ 'active': graphStore.currentGraphId === graph.id }"
              @click="selectGraph(graph.id)"
            >
              <i class="icon-file">📄</i>
              <span>{{ graph.name }}</span>
              <BaseButton @click.stop="confirmDeletion('graph', graph.id, graph.name, project.id)" type="danger" size="small" class="delete-btn">X</BaseButton>
            </div>
          </div>
        </div>
      </div>
    </div>

    <Modal :is-open="showDeleteConfirmModal" @close="cancelDeletion">
      <template #header><h3>Confirm Deletion</h3></template>
      <template #body>
        <p v-if="itemToDelete">Are you sure you want to delete "{{ itemToDelete.name }}" ({{ itemToDelete.type }})? This action cannot be undone.</p>
      </template>
      <template #footer>
        <BaseButton @click="cancelDeletion" type="secondary">Cancel</BaseButton>
        <BaseButton @click="executeDeletion" type="danger">Delete</BaseButton>
      </template>
    </Modal>
  </div>
</template>

<style scoped>
.project-manager {
  display: flex;
  flex-direction: column;
  gap: 15px;
  padding: 10px;
  height: 100%;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.header h4 {
  margin: 0;
  color: var(--color-heading);
}

.empty-state {
  font-style: italic;
  color: var(--color-secondary);
  text-align: center;
  padding: 20px 0;
  border: 1px dashed var(--color-border);
  border-radius: 5px;
  background-color: var(--color-background-mute);
}

.project-list, .graph-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.project-item {
  border: 1px solid var(--color-border-light);
  border-radius: 5px;
  overflow: hidden;
  margin-bottom: 10px;
}

.project-header, .graph-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  background-color: var(--color-background-mute);
  cursor: pointer;
  transition: background-color 0.2s ease;
  gap: 8px;
}

.project-header:hover, .graph-item:hover {
  background-color: var(--color-border-light);
}

.project-header span, .graph-item span {
  flex-grow: 1;
  font-weight: 500;
  color: var(--color-text);
}

.graph-list {
  padding: 5px 0 5px 15px; /* Indent graphs */
  background-color: var(--color-background-soft);
  border-top: 1px solid var(--color-border-light);
}

.graph-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 10px;
  border-bottom: 1px dashed var(--color-border-light);
  margin-bottom: 5px;
}

.graph-header h5 {
  margin: 0;
  font-weight: 500;
  color: var(--color-text);
}

.graph-item.active {
  background-color: var(--color-primary-hover);
  color: white;
  border-radius: 3px;
  box-shadow: 0 1px 3px rgba(0, 123, 255, 0.2);
}

.graph-item.active span, .graph-item.active .icon-file {
  color: white;
}

.delete-btn {
  padding: 4px 8px;
  font-size: 0.7em;
  background-color: var(--color-danger);
  color: white;
  border: none;
  border-radius: 3px;
}

.delete-btn:hover {
  background-color: #c82333;
}

.icon-folder, .icon-file {
  font-size: 1.1em;
  color: #777; /* Default icon color */
}

</style>



================================================
File: components/panels/CodePreviewPanel.vue
================================================
<script setup lang="ts">
import BaseButton from '../ui/BaseButton.vue'; // Updated import path
// This component will display the generated BUGS code.
// For now, it's a placeholder. Later it will:
// - Take the graph elements and generate BUGS code
// - Display the code in a syntax-highlighted editor
// - Possibly allow copying the code.
</script>

<template>
  <div class="code-preview-panel">
    <h4>Generated BUGS Code</h4>
    <div class="code-output">
      <p>Your BUGS model code will be generated and displayed here.</p>
      <pre class="code-block">
        <code>
model {
  # Example: Define a normal distribution
  # mu ~ dnorm(0, 1.0E-6)
  # tau ~ dgamma(0.01, 0.01)

  # Example: A simple deterministic relationship
  # theta <- exp(mu) / (1 + exp(mu))

  # Example: A loop for indexed variables (Plate)
  # for (i in 1:N) {
  #   y[i] ~ dbin(theta[i], n[i])
  # }

  # Add your nodes and connections visually to generate code!
}
        </code>
      </pre>
      <BaseButton class="copy-button" type="secondary">Copy Code</BaseButton>
    </div>
  </div>
</template>

<style scoped>
.code-preview-panel {
  padding: 15px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

h4 {
  margin: 0 0 10px 0;
  color: var(--color-heading);
  text-align: center;
  border-bottom: 1px solid var(--color-border-light);
  padding-bottom: 10px;
}

.code-output {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  background-color: #282c34; /* Dark background for code */
  color: #abb2bf; /* Light text for code */
  border-radius: 8px;
  overflow: hidden;
  position: relative;
}

.code-output p {
  padding: 15px;
  margin: 0;
  font-family: 'Fira Code', 'Cascadia Code', monospace;
  font-size: 0.9em;
  color: #61afef; /* A softer blue for info text */
}

.code-block {
  flex-grow: 1;
  padding: 15px;
  margin: 0;
  overflow: auto; /* Enable scrolling for code */
  font-family: 'Fira Code', 'Cascadia Code', monospace;
  font-size: 0.85em;
  line-height: 1.4;
  white-space: pre-wrap; /* Preserve whitespace and wrap */
  word-break: break-all; /* Break long words */
}

.copy-button {
  position: sticky; /* Sticky to the bottom of the code-output */
  bottom: 0;
  align-self: flex-end; /* Align to the right */
  margin: 10px;
  padding: 8px 15px;
  background-color: var(--color-secondary);
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  z-index: 10;
  opacity: 0.9;
}

.copy-button:hover {
  opacity: 1;
  background-color: var(--color-secondary-hover);
}
</style>



================================================
File: components/panels/DataInputPanel.vue
================================================
<!--
This component will display data associated with the BUGS model.
For now, it's a placeholder. Later it will likely involve:
- A list of declared data variables
- Input fields or a way to upload data
- Displaying sample data or value ranges.
-->
<script setup lang="ts">
// import BaseButton from '../ui/BaseButton.vue';

</script>

<template>
  <div class="data-input-panel">
    <h4>BUGS Model Data</h4>
    <div class="data-section">
      <p>Manage input data for your BUGS model here.</p>
      <p>
        Currently, this section is a placeholder for defining observed variables
        and uploading/entering their values.
      </p>
      <div class="data-placeholder">
        <i class="icon-data">📊</i>
        <span>Data definitions and values will appear here.</span>
        <!-- <BaseButton>Import Data</BaseButton> -->
        <!-- <BaseButton>Add Manually</BaseButton> -->
      </div>
    </div>
  </div>
</template>

<style scoped>
.data-input-panel {
  padding: 15px;
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

h4 {
  margin: 0 0 10px 0;
  color: var(--color-heading);
  text-align: center;
  border-bottom: 1px solid var(--color-border-light);
  padding-bottom: 10px;
}

.data-section {
  display: flex;
  flex-direction: column;
  gap: 15px;
  background-color: var(--color-background-mute);
  border: 1px solid var(--color-border-light);
  border-radius: 8px;
  padding: 15px;
  text-align: center;
}

.data-section p {
  margin: 0;
  font-size: 0.9em;
  color: var(--color-text);
  line-height: 1.5;
}

.data-placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 15px;
  padding: 20px;
  background-color: var(--color-background-soft);
  border: 1px dashed var(--color-border);
  border-radius: 5px;
  margin-top: 10px;
}

.icon-data {
  font-size: 3em;
  color: var(--color-secondary);
}

.data-placeholder span {
  font-style: italic;
  color: var(--color-secondary);
  font-size: 0.9em;
}

.data-placeholder button {
  width: 80%;
  max-width: 250px;
}
</style>



================================================
File: components/right-sidebar/NodePropertiesPanel.vue
================================================
<script setup lang="ts">
import { computed, ref, watch } from 'vue';
import type { GraphElement, GraphNode, GraphEdge, NodeType } from '../../types'; // Import NodeType
import BaseInput from '../ui/BaseInput.vue';   // Updated import path
import BaseSelect from '../ui/BaseSelect.vue'; // Updated import path
import BaseButton from '../ui/BaseButton.vue'; // Updated import path
import Modal from '../shared/Modal.vue'; // Import the Modal component

const props = defineProps<{
  selectedElement: GraphElement | null;
}>();

const emit = defineEmits<{
  (e: 'update-element', element: GraphElement): void;
  (e: 'delete-element', elementId: string): void;
}>();

// Internal state for form inputs, updated when selectedElement changes
const localElement = ref<GraphElement | null>(null);
const showDeleteConfirmModal = ref(false); // State for the custom confirmation modal

// Watch for changes in the selectedElement prop and deep copy it to localElement
watch(() => props.selectedElement, (newVal) => {
  localElement.value = newVal ? JSON.parse(JSON.stringify(newVal)) : null;
}, { deep: true, immediate: true });

// Computed properties to determine element type
const isNode = computed(() => localElement.value?.type === 'node');
const isEdge = computed(() => localElement.value?.type === 'edge');
const isPlate = computed(() => isNode.value && (localElement.value as GraphNode).nodeType === 'plate');

// Options for node types, reflecting BUGS model nodes
const nodeTypes: { value: NodeType; label: string }[] = [
  { value: 'stochastic', label: 'Stochastic' },
  { value: 'deterministic', label: 'Deterministic' },
  { value: 'constant', label: 'Constant' },
  { value: 'observed', label: 'Observed' },
  { value: 'plate', label: 'Plate' },
];

// Options for common BUGS distributions
const distributionOptions = [
  { value: 'dnorm', label: 'Normal (dnorm)' },
  { value: 'dbeta', label: 'Beta (dbeta)' },
  { value: 'dgamma', label: 'Gamma (dgamma)' },
  { value: 'dbin', label: 'Binomial (dbin)' },
  { value: 'dpois', label: 'Poisson (dpois)' },
  { value: 'dt', label: 'Student-t (dt)' },
  { value: 'dchisqr', label: 'Chi-squared (dchisqr)' },
  { value: 'dweib', label: 'Weibull (dweib)' },
  { value: 'dexp', label: 'Exponential (dexp)' },
  { value: 'dloglik', label: 'Log-Likelihood (dloglik)' },
  // Add more as needed based on JuliaBUGS support
];

// Options for edge relationship types
const relationshipTypeOptions = [
  { value: 'stochastic', label: 'Stochastic (~)' },
  { value: 'deterministic', label: 'Deterministic (<--)' }
];

/**
 * Emits an 'update-element' event with the current local element data.
 * This function is called when input fields change to update the graph store.
 */
const handleUpdate = () => {
  if (localElement.value) {
    emit('update-element', localElement.value);
  }
};

/**
 * Shows the confirmation modal before deleting an element.
 */
const confirmDelete = () => {
  if (localElement.value) {
    showDeleteConfirmModal.value = true;
  }
};

/**
 * Executes the deletion of the element after confirmation.
 */
const executeDelete = () => {
  if (localElement.value) {
    emit('delete-element', localElement.value.id);
    localElement.value = null; // Clear selected element after deletion
  }
  showDeleteConfirmModal.value = false; // Close the modal
};

/**
 * Cancels the deletion and closes the confirmation modal.
 */
const cancelDelete = () => {
  showDeleteConfirmModal.value = false;
};
</script>

<template>
  <div class="node-properties-panel">
    <h4>Properties</h4>

    <div v-if="!localElement" class="no-selection-message">
      <p>Select a node or edge on the canvas to view/edit its properties.</p>
    </div>

    <div v-else class="properties-form">
      <div class="form-group">
        <label for="element-id">ID:</label>
        <BaseInput id="element-id" :model-value="localElement.id" disabled />
      </div>

      <div class="form-group">
        <label for="element-name">Name:</label>
        <BaseInput id="element-name" v-model="localElement.name" @input="handleUpdate" />
      </div>

      <template v-if="isNode">
        <div class="form-group">
          <label for="node-type">Node Type:</label>
          <BaseSelect id="node-type" v-model="(localElement as GraphNode).nodeType" :options="nodeTypes" @change="handleUpdate" />
        </div>

        <template v-if="!isPlate">
          <div class="form-group">
            <label for="node-position-x">Position X:</label>
            <BaseInput
              id="node-position-x"
              type="number"
              v-model.number="(localElement as GraphNode).position.x"
              @input="handleUpdate"
            />
          </div>
          <div class="form-group">
            <label for="node-position-y">Position Y:</label>
            <BaseInput
              id="node-position-y"
              type="number"
              v-model.number="(localElement as GraphNode).position.y"
              @input="handleUpdate"
            />
          </div>

          <div class="form-section-header">BUGS Specific Properties</div>
          <div class="form-group">
            <label for="distribution">Distribution (~):</label>
            <BaseSelect
              id="distribution"
              v-model="(localElement as GraphNode).distribution"
              :options="distributionOptions"
              @change="handleUpdate"
              :model-value="(localElement as GraphNode).distribution ?? ''"
            />
          </div>
          <div class="form-group">
            <label for="equation">Equation (<--):</label>
            <BaseInput
              id="equation"
              v-model="(localElement as GraphNode).equation"
              placeholder="e.g., a + b * x"
              @input="handleUpdate"
              :model-value="(localElement as GraphNode).equation ?? ''"
            />
          </div>
          <div class="form-group checkbox-group">
            <label for="observed">Observed:</label>
            <input type="checkbox" id="observed" v-model="(localElement as GraphNode).observed" @change="handleUpdate" />
          </div>
          <div class="form-group">
            <label for="initial-value">Initial Value:</label>
            <BaseInput
              id="initial-value"
              v-model="(localElement as GraphNode).initialValue"
              placeholder="e.g., 0.5 or list(value=0.5)"
              @input="handleUpdate"
              :model-value="(localElement as GraphNode).initialValue ?? ''"
            />
          </div>
          <div class="form-group">
            <label for="variable-indices">Indices (e.g., i,j):</label>
            <BaseInput
              id="variable-indices"
              v-model="(localElement as GraphNode).indices"
              placeholder="e.g., i,j or 1:N"
              @input="handleUpdate"
              :model-value="(localElement as GraphNode).indices ?? ''"
            />
            <small class="help-text">Use comma-separated for multiple indices, e.g., 'i,j' or '1:N, 1:M'</small>
          </div>
        </template>

        <template v-else>
          <div class="form-section-header">Plate Properties</div>
          <div class="form-group">
            <label for="plate-loop-variable">Loop Variable:</label>
            <BaseInput
              id="plate-loop-variable"
              v-model="(localElement as GraphNode).loopVariable"
              placeholder="e.g., i"
              @input="handleUpdate"
              :model-value="(localElement as GraphNode).loopVariable ?? ''"
            />
          </div>
          <div class="form-group">
            <label for="plate-loop-range">Loop Range:</label>
            <BaseInput
              id="plate-loop-range"
              v-model="(localElement as GraphNode).loopRange"
              placeholder="e.g., 1:N"
              @input="handleUpdate"
              :model-value="(localElement as GraphNode).loopRange ?? ''"
            />
          </div>
          <small class="help-text">Define the iteration for this plate, e.g., 'i' in '1:N'</small>
        </template>
      </template>

      <template v-else-if="isEdge">
        <div class="form-group">
          <label for="edge-source">Source Node ID:</label>
          <BaseInput id="edge-source" :model-value="(localElement as GraphEdge).source" disabled />
        </div>
        <div class="form-group">
          <label for="edge-target">Target Node ID:</label>
          <BaseInput id="edge-target" :model-value="(localElement as GraphEdge).target" disabled />
        </div>
        <div class="form-group">
            <label for="edge-type">Relationship Type:</label>
            <BaseSelect
                id="edge-type"
                v-model="(localElement as GraphEdge).relationshipType"
                :options="relationshipTypeOptions"
                @change="handleUpdate"
                :model-value="(localElement as GraphEdge).relationshipType ?? ''"
            />
        </div>
      </template>

      <div class="action-buttons">
        <BaseButton @click="handleUpdate" type="primary">Apply Changes</BaseButton>
        <BaseButton @click="confirmDelete" type="danger">Delete Element</BaseButton>
      </div>
    </div>

    <Modal :is-open="showDeleteConfirmModal" @close="cancelDelete">
      <template #header><h3>Confirm Deletion</h3></template>
      <template #body>
        <p>Are you sure you want to delete "{{ localElement?.name || localElement?.id }}"? This action cannot be undone.</p>
      </template>
      <template #footer>
        <BaseButton @click="cancelDelete" type="secondary">Cancel</BaseButton>
        <BaseButton @click="executeDelete" type="danger">Delete</BaseButton>
      </template>
    </Modal>
  </div>
</template>

<style scoped>
.node-properties-panel {
  padding: 15px;
  height: 100%;
  display: flex;
  flex-direction: column;
}

h4 {
  margin: 0 0 10px 0;
  color: var(--color-heading);
  text-align: center;
  border-bottom: 1px solid var(--color-border-light);
  padding-bottom: 10px;
}

.no-selection-message {
  text-align: center;
  padding: 20px;
  color: var(--color-secondary);
  font-style: italic;
  background-color: var(--color-background-mute);
  border-radius: 8px;
  margin-top: 20px;
}

.properties-form {
  display: flex;
  flex-direction: column;
  gap: 15px;
  overflow-y: auto; /* Enable scrolling for the form content */
  padding-right: 5px; /* For scrollbar */
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.form-group label {
  font-weight: 500;
  color: var(--color-text);
  font-size: 0.9em;
}

.form-group input[type="text"],
.form-group input[type="number"],
.form-group select {
  width: 100%;
  box-sizing: border-box;
}

.form-group.checkbox-group {
  flex-direction: row; /* Align checkbox and label horizontally */
  align-items: center;
  gap: 10px;
}

.form-group input[type="checkbox"] {
  width: auto; /* Override 100% width */
  margin-top: 0;
}

.form-section-header {
  margin-top: 15px;
  padding-bottom: 5px;
  border-bottom: 1px dashed var(--color-border-light);
  font-weight: 600;
  color: var(--color-primary);
  font-size: 0.95em;
}

.help-text {
  font-size: 0.75em;
  color: #888;
  margin-top: 2px;
}

.action-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
  padding-top: 15px;
  border-top: 1px solid var(--color-border-light);
  flex-shrink: 0; /* Prevent buttons from being shrunk */
}
</style>



================================================
File: components/shared/Modal.vue
================================================
<script setup lang="ts">
import { watch } from 'vue';

const props = defineProps<{
  isOpen: boolean; // Controls modal visibility
}>();

const emit = defineEmits(['close']); // Emits 'close' when the modal should be hidden

// Watch for changes in `isOpen` to control body scrolling
watch(() => props.isOpen, (newVal) => {
  if (newVal) {
    document.body.style.overflow = 'hidden'; // Prevent scrolling when modal is open
  } else {
    document.body.style.overflow = ''; // Restore scrolling when modal is closed
  }
}, { immediate: true }); // Run immediately to set initial state

/**
 * Emits the 'close' event to hide the modal.
 */
const close = () => {
  emit('close');
};

/**
 * Handles clicks on the modal overlay. If the click is directly on the overlay
 * (not on the modal content), it closes the modal.
 * @param event The mouse event.
 */
const handleOverlayClick = (event: MouseEvent) => {
  if (event.target === event.currentTarget) {
    close();
  }
};
</script>

<template>
  <div v-if="isOpen" class="modal-overlay" @click="handleOverlayClick">
    <div class="modal-content" @click.stop> <div class="modal-header">
        <slot name="header"><h3>Modal Title</h3></slot> <button class="modal-close-button" @click="close">&times;</button> </div>
      <div class="modal-body">
        <slot name="body"></slot> </div>
      <div class="modal-footer">
        <slot name="footer"></slot> </div>
    </div>
  </div>
</template>

<style scoped>
/* Styles for the modal overlay and content are now primarily in global.css,
   but these scoped styles provide specific overrides or additions. */
.modal-overlay {
  /* Inherits most styles from global.css */
  /* Specific animations can be defined here if desired, or in global.css */
}

.modal-content {
  /* Inherits most styles from global.css */
}

.modal-header {
  /* Inherits most styles from global.css */
}

.modal-close-button {
  /* Inherits most styles from global.css */
}

.modal-body {
  /* Inherits most styles from global.css */
}

.modal-footer {
  /* Inherits most styles from global.css */
}
</style>



================================================
File: components/ui/BaseButton.vue
================================================
<script setup lang="ts">
import { computed } from 'vue';

const props = defineProps<{
  type?: 'primary' | 'secondary' | 'danger'; // Button style type
  size?: 'small' | 'medium' | 'large'; // Button size
  disabled?: boolean; // Whether the button is disabled
}>();

// Dynamically compute CSS classes based on props
const buttonClass = computed(() => {
  return {
    'base-button': true, // Always apply base styles
    [`button-${props.type || 'default'}`]: true, // Apply type-specific styles
    [`button-${props.size || 'medium'}`]: true, // Apply size-specific styles
    'button-disabled': props.disabled // Apply disabled style if prop is true
  };
});
</script>

<template>
  <button :class="buttonClass" :disabled="disabled">
    <slot></slot> </button>
</template>

<style scoped>
/* Base styles for all buttons */
.base-button {
  padding: 8px 15px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background-color: var(--color-background-mute);
  color: var(--color-text);
  cursor: pointer;
  transition: all 0.2s ease; /* Smooth transitions for hover/focus states */
  font-weight: 500;
  white-space: nowrap; /* Prevent text from wrapping inside the button */
}

/* Hover state for non-disabled buttons */
.base-button:hover:not(.button-disabled) {
  background-color: var(--color-border-light);
}

/* Focus state for accessibility */
.base-button:focus {
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); /* Focus ring */
}

/* Primary button styles */
.button-primary {
  background-color: var(--color-primary);
  color: white;
  border-color: var(--color-primary);
}

.button-primary:hover:not(.button-disabled) {
  background-color: var(--color-primary-hover);
  border-color: var(--color-primary-hover);
}

/* Secondary button styles */
.button-secondary {
  background-color: var(--color-secondary);
  color: white;
  border-color: var(--color-secondary);
}

.button-secondary:hover:not(.button-disabled) {
  background-color: var(--color-secondary-hover);
  border-color: var(--color-secondary-hover);
}

/* Danger button styles (for destructive actions) */
.button-danger {
  background-color: var(--color-danger);
  color: white;
  border-color: var(--color-danger);
}

.button-danger:hover:not(.button-disabled) {
  background-color: #c82333; /* Darker red */
  border-color: #bd2130;
}

/* Sizes */
.button-small {
  padding: 6px 10px;
  font-size: 0.8em;
}

.button-medium {
  padding: 8px 15px;
  font-size: 0.9em;
}

.button-large {
  padding: 12px 20px;
  font-size: 1.1em;
}

/* Disabled state */
.button-disabled {
  opacity: 0.6;
  cursor: not-allowed;
  background-color: var(--color-background-mute) !important;
  color: var(--color-secondary) !important;
  border-color: var(--color-border) !important;
}
</style>



================================================
File: components/ui/BaseInput.vue
================================================
<script setup lang="ts">
import { computed } from 'vue';

const props = defineProps<{
  modelValue: string | number; // Value bound via v-model
  type?: string; // Input type (e.g., 'text', 'number', 'email')
  placeholder?: string; // Placeholder text
  disabled?: boolean; // Whether the input is disabled
  readonly?: boolean; // Whether the input is read-only
}>();

const emit = defineEmits(['update:modelValue', 'change', 'input', 'keyup.enter']);

// Compute the input type, defaulting to 'text'
const inputType = computed(() => props.type || 'text');

/**
 * Handles the input event to update the v-model binding.
 * @param event The input event.
 */
const handleInput = (event: Event) => {
  const target = event.target as HTMLInputElement;
  emit('update:modelValue', target.value); // Emit for v-model
  emit('input', event); // Emit original input event
};

/**
 * Handles the change event.
 * @param event The change event.
 */
const handleChange = (event: Event) => {
  emit('change', event); // Emit original change event
};

/**
 * Handles the keyup event, specifically for the Enter key.
 * @param event The keyboard event.
 */
const handleKeyUpEnter = (event: KeyboardEvent) => {
  if (event.key === 'Enter') {
    emit('keyup.enter', event); // Emit custom keyup.enter event
  }
};
</script>

<template>
  <input
    :type="inputType"
    :value="modelValue"
    :placeholder="placeholder"
    :disabled="disabled"
    :readonly="readonly"
    @input="handleInput"
    @change="handleChange"
    @keyup="handleKeyUpEnter"
    class="base-input"
  />
</template>

<style scoped>
.base-input {
  padding: 8px 12px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background-color: var(--color-background-soft);
  color: var(--color-text);
  box-sizing: border-box; /* Include padding and border in the element's total width and height */
  font-size: 0.9em;
  transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Smooth transitions */
}

.base-input:focus {
  border-color: var(--color-primary);
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); /* Focus ring */
}

/* Styles for disabled and read-only states */
.base-input:disabled,
.base-input:readonly {
  background-color: var(--color-background-mute);
  cursor: not-allowed;
  opacity: 0.8;
}

/* Specific styles for number inputs to remove spin buttons */
.base-input[type="number"] {
  -moz-appearance: textfield; /* Firefox specific */
}
.base-input[type="number"]::-webkit-outer-spin-button,
.base-input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
</style>



================================================
File: components/ui/BaseSelect.vue
================================================
<script setup lang="ts">
import { computed } from 'vue';

// Interface for select options
interface SelectOption {
  value: string;
  label: string;
}

const props = defineProps<{
  modelValue: string; // The currently selected value (v-model binding)
  options: SelectOption[]; // Array of options to display
  disabled?: boolean; // Whether the select is disabled
}>();

const emit = defineEmits(['update:modelValue', 'change']);

/**
 * Handles the change event of the select element.
 * Emits the new value for v-model and the original change event.
 * @param event The change event.
 */
const handleChange = (event: Event) => {
  const target = event.target as HTMLSelectElement;
  emit('update:modelValue', target.value); // Emit for v-model
  emit('change', event); // Emit original change event
};

// Compute classes for styling, including disabled state
const selectClass = computed(() => ({
  'base-select': true,
  'select-disabled': props.disabled
}));
</script>

<template>
  <select
    :value="modelValue"
    @change="handleChange"
    :disabled="disabled"
    :class="selectClass"
  >
    <option v-for="option in options" :key="option.value" :value="option.value">
      {{ option.label }}
    </option>
  </select>
</template>

<style scoped>
.base-select {
  padding: 8px 12px;
  border: 1px solid var(--color-border);
  border-radius: 4px;
  background-color: var(--color-background-soft);
  color: var(--color-text);
  box-sizing: border-box;
  font-size: 0.9em;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  /* Remove default browser styling for a custom look */
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  /* Custom arrow icon using SVG data URI */
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236c757d'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
  background-size: 1.2em;
  cursor: pointer;
}

.base-select:focus {
  border-color: var(--color-primary);
  outline: none;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.base-select:disabled {
  background-color: var(--color-background-mute);
  cursor: not-allowed;
  opacity: 0.8;
}
</style>



================================================
File: composables/useGraphElements.ts
================================================
import { computed, ref } from 'vue';
import { useGraphStore } from '../stores/graphStore';
import type { GraphElement, GraphNode } from '../types';

/**
 * Composable for managing graph elements (nodes and edges) within the current active graph.
 * It provides reactive access to elements and functions to modify them,
 * which in turn updates the Pinia graph store.
 */
export function useGraphElements() {
  const graphStore = useGraphStore();

  // Reactive reference to the currently selected element for the properties panel.
  // This is managed locally within the composable and updated by components (e.g., GraphEditor).
  const selectedElement = ref<GraphElement | null>(null);

  // Computed property to access elements of the currently selected graph from the store.
  // This ensures that any changes to elements are automatically reflected in the UI
  // and persisted via the store's setter.
  const elements = computed<GraphElement[]>({
    get: () => graphStore.currentGraphElements,
    set: (newElements) => {
      if (graphStore.currentGraphId) {
        // When elements are updated, call the store's action to save them.
        graphStore.updateGraphElements(graphStore.currentGraphId, newElements);
      }
    }
  });

  /**
   * Adds a new graph element (node or edge) to the current graph.
   * @param {GraphElement} newElement - The element to add.
   */
  const addElement = (newElement: GraphElement) => {
    // Append the new element to the existing array.
    // The computed setter for `elements` will handle updating the store.
    elements.value = [...elements.value, newElement];
    selectedElement.value = newElement; // Automatically select the newly added element
  };

  /**
   * Updates an existing graph element in the current graph.
   * @param {GraphElement} updatedElement - The element with updated properties.
   */
  const updateElement = (updatedElement: GraphElement) => {
    // Map over the elements and replace the one with a matching ID.
    elements.value = elements.value.map(el =>
      el.id === updatedElement.id ? updatedElement : el
    );
    // If the updated element was currently selected, keep the `selectedElement` in sync.
    if (selectedElement.value?.id === updatedElement.id) {
      selectedElement.value = updatedElement;
    }
  };

  /**
   * Deletes a graph element from the current graph.
   * @param {string} elementId - The ID of the element to delete.
   */
  const deleteElement = (elementId: string) => {
    // Filter out the element with the matching ID.
    elements.value = elements.value.filter(el => el.id !== elementId);
    // If the deleted element was selected, deselect it.
    if (selectedElement.value?.id === elementId) {
      selectedElement.value = null;
    }
  };

  return {
    elements,          // Reactive array of all graph elements in the current graph
    selectedElement,   // Reactive reference to the currently selected element
    addElement,        // Function to add a new element
    updateElement,     // Function to update an existing element
    deleteElement,     // Function to delete an element
  };
}



================================================
File: composables/useGraphInstance.ts
================================================
import cytoscape from 'cytoscape';
import type { Core, ElementDefinition, Stylesheet } from 'cytoscape';
import gridGuide from 'cytoscape-grid-guide';
import contextMenus from 'cytoscape-context-menus';

cytoscape.use(gridGuide);
cytoscape.use(contextMenus);

let cyInstance: Core | null = null;

/**
 * Composable for initializing and managing the Cytoscape.js core instance.
 */
export function useGraphInstance() {

  /**
   * Initializes a new Cytoscape.js instance with predefined styles.
   */
  const initCytoscape = (container: HTMLElement, initialElements: ElementDefinition[]): Core => {
    if (cyInstance) {
      cyInstance.destroy();
      cyInstance = null;
    }

    const options: cytoscape.CytoscapeOptions = {
      container: container,
      elements: initialElements,
      style: [
        // --- All Node Styles are correct and remain unchanged ---
        {
          selector: 'node',
          style: { 'background-color': '#e0e0e0', 'border-color': '#555', 'border-width': 2, 'label': 'data(name)', 'text-valign': 'center', 'text-halign': 'center', 'padding': '10px', 'font-size': '10px', 'text-wrap': 'wrap', 'text-max-width': '80px', 'height': '60px', 'width': '60px', 'line-height': 1.2, 'border-style': 'solid', 'z-index': 10 } as Stylesheet['style'],
        },
        {
          selector: 'node[nodeType="plate"]',
          style: { 'background-color': '#f0f8ff', 'border-color': '#4682b4', 'border-style': 'dashed', 'shape': 'round-rectangle', 'corner-radius': '10px', } as Stylesheet['style'],
        },
        {
          selector: ':parent',
          style: { 'text-valign': 'top', 'text-halign': 'center', 'padding': '15px', 'background-opacity': 0.2, 'z-index': 5 } as Stylesheet['style'],
        },
        {
          selector: 'node[nodeType="stochastic"]',
          style: { 'background-color': '#ffe0e0', 'border-color': '#dc3545', 'shape': 'ellipse' } as Stylesheet['style'],
        },
        {
          selector: 'node[nodeType="deterministic"]',
          style: { 'background-color': '#e0ffe0', 'border-color': '#28a745', 'shape': 'round-rectangle' } as Stylesheet['style'],
        },
        {
          selector: 'node[nodeType="constant"]',
          style: { 'background-color': '#e9ecef', 'border-color': '#6c757d', 'shape': 'rectangle' } as Stylesheet['style'],
        },
        {
          selector: 'node[nodeType="observed"]',
          style: { 'background-color': '#e0f0ff', 'border-color': '#007bff', 'border-style': 'dashed', 'shape': 'ellipse' } as Stylesheet['style'],
        },

        // --- Edge Styles ---
        {
          selector: 'edge',
          style: {
            'width': 3,
            'line-color': '#a0a0a0',
            'target-arrow-color': '#a0a0a0',
            'target-arrow-shape': 'triangle',
            'curve-style': 'bezier',
            'z-index': 1,
            // --- FIX: Re-added the label property to display edge names ---
            'label': 'data(name)',
            'font-size': '8px',
            'text-rotation': 'autorotate',
            'text-background-opacity': 1,
            'text-background-color': '#ffffff',
            'text-background-padding': '3px',
            'text-border-width': 1,
            'text-border-color': '#ccc',
          } as Stylesheet['style'],
        },
        {
          selector: 'edge[relationshipType="stochastic"]',
          style: { 'line-color': '#dc3545', 'target-arrow-color': '#dc3545', 'line-style': 'dashed' } as Stylesheet['style'],
        },
        {
          selector: 'edge[relationshipType="deterministic"]',
          style: { 'line-color': '#28a745', 'target-arrow-color': '#28a745', 'line-style': 'solid' } as Stylesheet['style'],
        },
        // --- Interaction Styles ---
        {
          selector: '.cy-selected',
          style: { 'border-width': 3, 'border-color': '#007acc', 'overlay-color': '#007acc', 'overlay-opacity': 0.2 } as Stylesheet['style'],
        },
        {
          selector: '.cy-connecting',
          style: { 'background-color': '#007acc', 'border-color': '#0060a0', 'color': '#ffffff', 'overlay-color': '#007acc', 'overlay-opacity': 0.2 } as Stylesheet['style'],
        }
      ] as Stylesheet[],
      layout: { name: 'preset' },
      minZoom: 0.1,
      maxZoom: 2,
      boxSelectionEnabled: true,
      wheelSensitivity: 0.2,
      autounselectify: false,
    };

    cyInstance = cytoscape(options);

    (cyInstance as any).gridGuide({ drawGrid: false, snapToGridOnRelease: true, snapToGridDuringDrag: true, gridSpacing: 20 });
    (cyInstance as any).contextMenus({ menuItems: [ { id: 'remove', content: 'Remove', selector: 'node, edge', onClickFunction: (evt: any) => evt.target.remove() } ] });

    return cyInstance;
  };

  const destroyCytoscape = (cy: Core): void => {
    if (cy) {
      cy.destroy();
      cyInstance = null;
    }
  };

  const getCyInstance = (): Core | null => cyInstance;

  return { initCytoscape, destroyCytoscape, getCyInstance };
}



================================================
File: composables/useGraphSync.ts
================================================
import { watch } from 'vue';
import type { Core } from 'cytoscape';
import type { GraphElement, GraphNode, GraphEdge } from '../types';

/**
 * Composable to synchronize a Cytoscape.js instance with a reactive array of GraphElements.
 * It observes changes in the elements array and updates the Cytoscape graph accordingly.
 *
 * @param {() => Core | null} getCyInstance - A function that returns the current Cytoscape.js Core instance.
 * @param {GraphElement[]} elements - The reactive array of graph elements (nodes and edges).
 */
export function useGraphSync(getCyInstance: () => Core | null, elements: GraphElement[]) {

  // Watch the `elements` array deeply for changes
  watch(elements, (newElements, oldElements) => {
    const cy = getCyInstance();
    if (!cy) {
      console.warn('Cytoscape instance not available for synchronization.');
      return;
    }

    const newElementIds = new Set(newElements.map(el => el.id));
    const oldElementIds = new Set(oldElements.map(el => el.id));

    // 1. Remove elements that are in oldElements but not in newElements
    cy.elements().forEach(cyEl => {
      if (!newElementIds.has(cyEl.id())) {
        cyEl.remove();
      }
    });

    // 2. Add or update elements that are in newElements
    newElements.forEach(newEl => {
      const existingCyEl = cy.getElementById(newEl.id);

      if (!existingCyEl.length) {
        // Element does not exist in Cytoscape, add it
        if (newEl.type === 'node') {
          const nodeData = newEl as GraphNode;
          cy.add({
            group: 'nodes',
            data: nodeData,
            position: nodeData.position
          });
        } else if (newEl.type === 'edge') {
          const edgeData = newEl as GraphEdge;
          cy.add({
            group: 'edges',
            data: edgeData,
            source: edgeData.source,
            target: edgeData.target
          });
        }
      } else {
        // Element exists, update its data (e.g., name, nodeType, position after drag)
        // This is crucial for properties panel changes to reflect on the graph
        existingCyEl.data(newEl);
        if (newEl.type === 'node') {
          // Only update position if it has changed to avoid unnecessary re-renders
          const newNodePos = (newEl as GraphNode).position;
          const currentCyPos = existingCyEl.position();
          if (newNodePos.x !== currentCyPos.x || newNodePos.y !== currentCyPos.y) {
            existingCyEl.position(newNodePos);
          }
        }
      }
    });
  }, { deep: true }); // Deep watch is necessary for nested changes within elements
}



================================================
File: composables/useGridSnapping.ts
================================================
import { ref, computed, watch } from 'vue';
import type { Core } from 'cytoscape';

/**
 * Composable for managing grid snapping and visual grid background for Cytoscape.js.
 * It controls the CSS variable for grid size and adds/removes a class for the grid background.
 * @param {Function} getCyInstance - A function that returns the Cytoscape.js core instance.
 */
export function useGridSnapping(getCyInstance: () => Core | null) {
  const isGridEnabledRef = ref<boolean>(false);
  const gridSizeRef = ref<number>(20); // Default grid size in pixels

  // Computed property for the CSS variable value
  const cssGridSize = computed<string>(() => `${gridSizeRef.value}px`);

  /**
   * Updates the CSS class and variable on the Cytoscape container
   * to show or hide the visual grid background.
   */
  const updateGridBackground = () => {
    const cy = getCyInstance();
    if (cy) {
      const container = cy.container();
      if (container) {
        if (isGridEnabledRef.value && gridSizeRef.value > 0) {
          container.classList.add('grid-background');
          container.style.setProperty('--grid-size', cssGridSize.value);
        } else {
          container.classList.remove('grid-background');
          container.style.removeProperty('--grid-size');
        }
      }
    }
  };

  /**
   * Enables the visual grid. Note: Actual snapping logic is handled in GraphCanvas.vue's
   * 'dragfree' event listener, where nodes are programmatically snapped to grid.
   */
  const enableGridSnapping = (): void => {
    isGridEnabledRef.value = true;
    updateGridBackground();
    console.log(`Visual grid enabled with ${gridSizeRef.value}px.`);
  };

  /**
   * Disables the visual grid.
   */
  const disableGridSnapping = (): void => {
    isGridEnabledRef.value = false;
    updateGridBackground();
    console.log('Visual grid disabled.');
  };

  /**
   * Sets a new grid size and updates the visual grid if enabled.
   * @param {number} size - The new grid size in pixels.
   */
  const setGridSize = (size: number): void => {
    gridSizeRef.value = size;
    if (isGridEnabledRef.value) {
      updateGridBackground();
    }
  };

  // Watch for changes in grid state or size to re-apply grid background
  watch([isGridEnabledRef, gridSizeRef], updateGridBackground);

  return {
    isGridEnabledRef, // Reactive state for grid enabled/disabled
    gridSizeRef,      // Reactive state for grid size
    cssGridSize,      // Computed CSS variable string
    enableGridSnapping,
    disableGridSnapping,
    setGridSize,
  };
}



================================================
File: stores/graphStore.ts
================================================
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import type { GraphElement } from '../types';

// Interface defining the structure of a graph's content
export interface GraphContent {
  graphId: string;
  elements: GraphElement[]; // Array of nodes and edges
  // Add other graph-specific settings like zoom, pan position etc. if needed
}

export const useGraphStore = defineStore('graph', () => {
  // A Map to store all graph contents, keyed by graphId
  const graphContents = ref<Map<string, GraphContent>>(new Map());
  // The ID of the currently selected graph
  const currentGraphId = ref<string | null>(null);

  /**
   * Computed property that provides reactive access to the elements of the currently selected graph.
   * Its setter ensures that any modifications to the elements array are persisted.
   */
  const currentGraphElements = computed<GraphElement[]>({
    get: () => {
      if (currentGraphId.value && graphContents.value.has(currentGraphId.value)) {
        return graphContents.value.get(currentGraphId.value)!.elements;
      }
      return []; // Return empty array if no graph is selected or found
    },
    set: (newElements: GraphElement[]) => {
      if (currentGraphId.value && graphContents.value.has(currentGraphId.value)) {
        // Update the elements array for the current graph in the map
        graphContents.value.get(currentGraphId.value)!.elements = newElements;
        // Immediately save the updated graph content to local storage
        saveGraph(currentGraphId.value, graphContents.value.get(currentGraphId.value)!);
      }
    }
  });

  /**
   * Sets the currently active graph. If the graph is not in memory, attempts to load it.
   * @param {string | null} graphId - The ID of the graph to select, or null to deselect.
   */
  const selectGraph = (graphId: string | null) => {
    currentGraphId.value = graphId;
    if (graphId && !graphContents.value.has(graphId)) {
      loadGraph(graphId); // Attempt to load if not already in memory
    }
  };

  /**
   * Creates a new empty graph content object and adds it to the store and persistence.
   * @param {string} graphId - The unique ID for the new graph.
   */
  const createNewGraphContent = (graphId: string) => {
    const newContent: GraphContent = {
      graphId: graphId,
      elements: [], // Start with an empty array of elements
    };
    graphContents.value.set(graphId, newContent);
    saveGraph(graphId, newContent); // Persist the new empty graph
  };

  /**
   * Updates the elements of a specific graph.
   * @param {string} graphId - The ID of the graph to update.
   * @param {GraphElement[]} newElements - The new array of elements for the graph.
   */
  const updateGraphElements = (graphId: string, newElements: GraphElement[]) => {
    if (graphContents.value.has(graphId)) {
      graphContents.value.get(graphId)!.elements = newElements;
      saveGraph(graphId, graphContents.value.get(graphId)!); // Persist changes
    }
  };

  /**
   * Deletes a graph's content from the store and persistence.
   * @param {string} graphId - The ID of the graph to delete.
   */
  const deleteGraphContent = (graphId: string) => {
    graphContents.value.delete(graphId); // Remove from reactive map
    localStorage.removeItem(`doodlebugs-graph-${graphId}`); // Remove from local storage
    if (currentGraphId.value === graphId) {
      currentGraphId.value = null; // Deselect if the current graph is deleted
    }
  };

  // --- Persistence Methods (Local Storage) ---

  /**
   * Saves a specific graph's content to local storage.
   * @param {string} graphId - The ID of the graph to save.
   * @param {GraphContent} content - The content object of the graph.
   */
  const saveGraph = (graphId: string, content: GraphContent) => {
    localStorage.setItem(`doodlebugs-graph-${graphId}`, JSON.stringify(content));
  };

  /**
   * Loads a specific graph's content from local storage into the store.
   * @param {string} graphId - The ID of the graph to load.
   * @returns {GraphContent | null} The loaded graph content, or null if not found.
   */
  const loadGraph = (graphId: string): GraphContent | null => {
    const storedContent = localStorage.getItem(`doodlebugs-graph-${graphId}`);
    if (storedContent) {
      const content: GraphContent = JSON.parse(storedContent);
      graphContents.value.set(graphId, content); // Add to reactive map
      return content;
    }
    return null;
  };

  return {
    graphContents,        // Reactive map of all graph contents
    currentGraphId,       // Reactive ID of the currently selected graph
    currentGraphElements, // Computed elements of the current graph (read/write)
    selectGraph,
    createNewGraphContent,
    updateGraphElements,
    deleteGraphContent,
    saveGraph,
    loadGraph,
  };
});



================================================
File: stores/projectStore.ts
================================================
import { defineStore } from 'pinia';
import { ref, computed, watch } from 'vue';
import { useGraphStore } from './graphStore'; // Import the graph store

// Interface for graph metadata (stored within a project)
export interface GraphMeta {
  id: string;
  name: string;
  createdAt: number;
  lastModified: number;
}

// Interface for a project
export interface Project {
  id: string;
  name: string;
  createdAt: number;
  lastModified: number;
  graphs: GraphMeta[]; // List of graph metadata belonging to this project
}

export const useProjectStore = defineStore('project', () => {
  const projects = ref<Project[]>([]); // Reactive array of all projects
  const currentProjectId = ref<string | null>(null); // ID of the currently selected project

  const graphStore = useGraphStore(); // Get instance of the graph store

  /**
   * Creates a new project and adds it to the list.
   * @param {string} name - The name of the new project.
   */
  const createProject = (name: string) => {
    const newProject: Project = {
      id: `project_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`, // Unique ID
      name: name,
      createdAt: Date.now(),
      lastModified: Date.now(),
      graphs: [], // New projects start with no graphs
    };
    projects.value.push(newProject); // Add to reactive array
    saveProjects(); // Persist changes
    selectProject(newProject.id); // Automatically select the new project
  };

  /**
   * Sets the currently active project.
   * Automatically selects the first graph in the project if available.
   * @param {string | null} projectId - The ID of the project to select, or null to deselect.
   */
  const selectProject = (projectId: string | null) => {
    currentProjectId.value = projectId;
    if (projectId) {
      const project = projects.value.find(p => p.id === projectId);
      if (project && project.graphs.length > 0) {
        // Select the first graph in the project, or last opened (future enhancement)
        graphStore.selectGraph(project.graphs[0].id);
      } else {
        graphStore.selectGraph(null); // No graphs in this project, deselect current graph
      }
    } else {
      graphStore.selectGraph(null); // No project selected, deselect current graph
    }
  };

  /**
   * Deletes a project and all its associated graphs.
   * @param {string} projectId - The ID of the project to delete.
   */
  const deleteProject = (projectId: string) => {
    const projectToDelete = projects.value.find(p => p.id === projectId);
    if (projectToDelete) {
      // Delete all graphs associated with this project from the graph store
      projectToDelete.graphs.forEach(graphMeta => {
        graphStore.deleteGraphContent(graphMeta.id);
      });
      // Remove the project from the reactive array
      projects.value = projects.value.filter(p => p.id !== projectId);
      // If the deleted project was current, deselect it
      if (currentProjectId.value === projectId) {
        currentProjectId.value = null;
        graphStore.selectGraph(null); // Also deselect any active graph
      }
      saveProjects(); // Persist changes
    }
  };

  /**
   * Computed property for the currently selected project object.
   */
  const currentProject = computed(() => {
    return projects.value.find(p => p.id === currentProjectId.value) || null;
  });

  /**
   * Adds a new graph (metadata) to a specified project.
   * Also creates an empty content entry for this new graph in the graph store.
   * @param {string} projectId - The ID of the project to add the graph to.
   * @param {string} graphName - The name of the new graph.
   */
  const addGraphToProject = (projectId: string, graphName: string) => {
    const project = projects.value.find(p => p.id === projectId);
    if (project) {
      const newGraphMeta: GraphMeta = {
        id: `graph_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`, // Unique ID
        name: graphName,
        createdAt: Date.now(),
        lastModified: Date.now(),
      };
      project.graphs.push(newGraphMeta); // Add metadata to project
      project.lastModified = Date.now(); // Update project modification timestamp
      saveProjects(); // Persist changes
      graphStore.createNewGraphContent(newGraphMeta.id); // Create empty content for new graph
      graphStore.selectGraph(newGraphMeta.id); // Select the new graph
    }
  };

  /**
   * Deletes a graph from a specified project and its content from the graph store.
   * @param {string} projectId - The ID of the project containing the graph.
   * @param {string} graphId - The ID of the graph to delete.
   */
  const deleteGraphFromProject = (projectId: string, graphId: string) => {
    const project = projects.value.find(p => p.id === projectId);
    if (project) {
      project.graphs = project.graphs.filter(g => g.id !== graphId); // Remove metadata
      project.lastModified = Date.now(); // Update project modification timestamp
      saveProjects(); // Persist changes
      graphStore.deleteGraphContent(graphId); // Delete graph content as well
    }
  };

  /**
   * Returns the list of graph metadata for a given project.
   * @param {string} projectId - The ID of the project.
   * @returns {GraphMeta[]} An array of graph metadata.
   */
  const getGraphsForProject = (projectId: string): GraphMeta[] => {
    return projects.value.find(p => p.id === projectId)?.graphs || [];
  };

  // --- Persistence Methods (Local Storage) ---

  /**
   * Saves the entire projects array to local storage.
   */
  const saveProjects = () => {
    localStorage.setItem('doodlebugs-projects', JSON.stringify(projects.value));
  };

  /**
   * Loads projects from local storage into the store.
   */
  const loadProjects = () => {
    const storedProjects = localStorage.getItem('doodlebugs-projects');
    if (storedProjects) {
      projects.value = JSON.parse(storedProjects);
    }
  };

  // Watch for changes in current project and update graph store accordingly
  watch(currentProjectId, (newProjectId) => {
    if (newProjectId) {
      const project = projects.value.find(p => p.id === newProjectId);
      if (project && project.graphs.length > 0) {
        // If a project is selected and it has graphs, ensure one is selected in graphStore
        if (!graphStore.currentGraphId || !project.graphs.some(g => g.id === graphStore.currentGraphId)) {
          graphStore.selectGraph(project.graphs[0].id); // Select the first graph by default
        }
      } else {
        graphStore.selectGraph(null); // If no graphs in project, deselect graph
      }
    } else {
      graphStore.selectGraph(null); // If no project selected, deselect graph
    }
  }, { immediate: true }); // Run immediately on component mount

  return {
    projects,
    currentProjectId,
    currentProject,
    createProject,
    selectProject,
    deleteProject,
    addGraphToProject,
    deleteGraphFromProject,
    getGraphsForProject,
    loadProjects,
  };
});



================================================
File: types/cytoscape-snap-to-grid.d.ts
================================================
declare module 'cytoscape-snap-to-grid' {
  import cytoscape from 'cytoscape';

  interface SnapToGridOptions {
    grid?: boolean; // enable/disable grid (snap to grid)
    zoom?: boolean; // enable/disable zooming
    stackOrder?: number; // integer z-index for the grid lines
    visual?: boolean; // show or hide the grid lines
    gridLineColor?: string; // color of the grid lines
    gridLineWidth?: number; // width of the grid lines
    gridSpacing?: number; // spacing of the grid lines
    strokeStyle?: string; // color of the grid lines
    lineWidth?: number; // width of the grid lines
    lineDash?: number[]; // line dash of the grid lines
    lineDashOffset?: number; // line dash offset of the grid lines
    // Add any other specific options you might use from the plugin
  }

  interface CytoscapeMethods {
    snapToGrid: {
      (action: 'snap', options?: SnapToGridOptions): void;
      (action: 'unsnap'): void;
      // You might need to add more method signatures based on the plugin's API
      // e.g., (action: 'gridSize', size: number): void;
      (options?: SnapToGridOptions): void; // For initial setup
    };
  }

  // Augment Cytoscape.Core to include the new method
  namespace cytoscape {
    interface Core extends CytoscapeMethods {}
  }

  // The default export of the module is usually the plugin function itself
  function snapToGrid(cytoscape: any): void; // The plugin function expects cytoscape as arg
  export = snapToGrid;
}


================================================
File: types/index.ts
================================================
// Define the specific types of nodes in a BUGS model
export type NodeType = 'stochastic' | 'deterministic' | 'constant' | 'observed' | 'plate';

// Define a type for items that can be selected/dragged from the palette
// This includes actual node types and special actions like adding edges
export type PaletteItemType = NodeType | 'add-stochastic-edge' | 'add-deterministic-edge';

// Define a basic node type for the graph
export interface GraphNode {
  id: string;
  name: string;
  type: 'node'; // Discriminator for union type
  nodeType: NodeType; // The specific type of BUGS node
  position: { x: number; y: number; }; // Position on the canvas

  // BUGS specific properties (optional, and might be combined based on context)
  distribution?: string; // e.g., 'dnorm', 'dbeta' for stochastic nodes
  equation?: string;    // for deterministic nodes, e.g., 'a + b * x'
  observed?: boolean;   // true if this is an observed variable (data)
  initialValue?: any;   // Initial value for MCMC chains (can be a number, string, or object)
  indices?: string;     // For indexed variables, e.g., 'i', 'i,j', '1:N'
  loopVariable?: string; // For plate nodes (e.g., 'i')
  loopRange?: string;    // For plate nodes (e.g., '1:N')
}

// Define a basic edge type for the graph
export interface GraphEdge {
  id: string;
  name?: string; // Optional name for the edge
  type: 'edge'; // Discriminator for union type
  source: string; // ID of the source node
  target: string; // ID of the target node;
  relationshipType?: 'stochastic' | 'deterministic'; // e.g., '~' or '<-'
}

// Union type for all graph elements
export type GraphElement = GraphNode | GraphEdge;

// --- Augment Cytoscape.js types for custom data properties ---
// This extends Cytoscape's internal types so that data properties are type-safe
declare module 'cytoscape' {
  interface NodeSingular {
    data(key: 'id'): string;
    data(key: 'name'): string;
    data(key: 'type'): 'node';
    data(key: 'nodeType'): NodeType; // Use our custom NodeType
    data(key: 'position'): { x: number; y: number; };
    data(key: 'distribution'): string | undefined;
    data(key: 'equation'): string | undefined;
    data(key: 'observed'): boolean | undefined;
    data(key: 'initialValue'): any | undefined;
    data(key: 'indices'): string | undefined;
    data(key: 'loopVariable'): string | undefined;
    data(key: 'loopRange'): string | undefined;
    data(key: string): any; // Fallback for other data properties
    // Setters
    data(key: 'id', value: string): NodeSingular;
    data(key: 'name', value: string): NodeSingular;
    data(key: 'type', value: 'node'): NodeSingular;
    data(key: 'nodeType', value: NodeType): NodeSingular;
    data(key: 'position', value: { x: number; y: number; }): NodeSingular;
    data(key: 'distribution', value: string | undefined): NodeSingular;
    data(key: 'equation', value: string | undefined): NodeSingular;
    data(key: 'observed', value: boolean | undefined): NodeSingular;
    data(key: 'initialValue', value: any | undefined): NodeSingular;
    data(key: 'indices', value: string | undefined): NodeSingular;
    data(key: 'loopVariable', value: string | undefined): NodeSingular;
    data(key: 'loopRange', value: string | undefined): NodeSingular;
    data(key: string, value: any): NodeSingular; // Fallback for other data properties
    data(obj: Partial<GraphNode>): NodeSingular; // For updating multiple properties at once
  }

  interface EdgeSingular {
    data(key: 'id'): string;
    data(key: 'name'): string | undefined;
    data(key: 'type'): 'edge';
    data(key: 'source'): string;
    data(key: 'target'): string;
    data(key: 'relationshipType'): 'stochastic' | 'deterministic' | undefined;
    data(key: string): any; // Fallback for other data properties
    // Setters
    data(key: 'id', value: string): EdgeSingular;
    data(key: 'name', value: string | undefined): EdgeSingular;
    data(key: 'type', value: 'edge'): EdgeSingular;
    data(key: 'source', value: string): EdgeSingular;
    data(key: 'target', value: string): EdgeSingular;
    data(key: 'relationshipType', value: 'stochastic' | 'deterministic' | undefined): EdgeSingular;
    data(key: string, value: any): EdgeSingular; // Fallback for other data properties
    data(obj: Partial<GraphEdge>): EdgeSingular; // For updating multiple properties at once
  }
}


